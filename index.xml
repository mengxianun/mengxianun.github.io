<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Academic</title>
    <link>/</link>
      <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <description>Academic</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 24 Apr 2022 10:02:10 +0800</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Academic</title>
      <link>/</link>
    </image>
    
    <item>
      <title>Frp</title>
      <link>/posts/frp/</link>
      <pubDate>Sun, 24 Apr 2022 10:02:10 +0800</pubDate>
      <guid>/posts/frp/</guid>
      <description>&lt;h3 id=&#34;服务端配置&#34;&gt;服务端配置&lt;/h3&gt;
&lt;p&gt;/etc/frp/frps.ini&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[common]
bind_port = 7000
token = ***
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;客户端配置&#34;&gt;客户端配置&lt;/h3&gt;
&lt;p&gt;/etc/frp/frpc.ini&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[common]
server_addr = 服务端IP(公网)
server_port = 7000
token = ***

[gitlab]
type = tcp
local_ip = 内网服务IP
local_port = 内网服务端口
remote_port = 公网服务端口
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;管理&#34;&gt;管理&lt;/h3&gt;
&lt;h4 id=&#34;重启&#34;&gt;重启&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;systemctl restart frpc.service
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Mongo</title>
      <link>/posts/mongo/</link>
      <pubDate>Thu, 21 Apr 2022 11:18:16 +0800</pubDate>
      <guid>/posts/mongo/</guid>
      <description>&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;h4 id=&#34;docker&#34;&gt;docker&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;docker run -d -p 27017:27017 --name metasearch-mongo -e MONGO_INITDB_DATABASE=db_name -e MONGO_INITDB_ROOT_USERNAME=username -e MONGO_INITDB_ROOT_PASSWORD=password -v /data/mongo:/data/db mongo
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rabbit</title>
      <link>/posts/rabbit/</link>
      <pubDate>Tue, 29 Mar 2022 10:36:47 +0800</pubDate>
      <guid>/posts/rabbit/</guid>
      <description>&lt;h4 id=&#34;安装red-hat-7-centos-7&#34;&gt;安装（Red Hat 7, CentOS 7）&lt;/h4&gt;
&lt;h5 id=&#34;导入签名密钥&#34;&gt;导入签名密钥&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;## primary RabbitMQ signing key
rpm --import https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc
## modern Erlang repository
rpm --import https://packagecloud.io/rabbitmq/erlang/gpgkey
## RabbitMQ server repository
rpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;添加-yum-存储库&#34;&gt;添加 Yum 存储库&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# In /etc/yum.repos.d/rabbitmq.repo

##
## Zero dependency Erlang
##

[rabbitmq_erlang]
name=rabbitmq_erlang
baseurl=https://packagecloud.io/rabbitmq/erlang/el/7/$basearch
repo_gpgcheck=1
gpgcheck=1
enabled=1
# PackageCloud&#39;s repository key and RabbitMQ package signing key
gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey
       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc
sslverify=1
sslcacert=/etc/pki/tls/certs/ca-bundle.crt
metadata_expire=300

[rabbitmq_erlang-source]
name=rabbitmq_erlang-source
baseurl=https://packagecloud.io/rabbitmq/erlang/el/7/SRPMS
repo_gpgcheck=1
gpgcheck=0
enabled=1
gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey
sslverify=1
sslcacert=/etc/pki/tls/certs/ca-bundle.crt
metadata_expire=300

##
## RabbitMQ server
##

[rabbitmq_server]
name=rabbitmq_server
baseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/7/$basearch
repo_gpgcheck=1
gpgcheck=1
enabled=1
# PackageCloud&#39;s repository key and RabbitMQ package signing key
gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey
       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc
sslverify=1
sslcacert=/etc/pki/tls/certs/ca-bundle.crt
metadata_expire=300

[rabbitmq_server-source]
name=rabbitmq_server-source
baseurl=https://packagecloud.io/rabbitmq/rabbitmq-server/el/7/SRPMS
repo_gpgcheck=1
gpgcheck=0
enabled=1
gpgkey=https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey
sslverify=1
sslcacert=/etc/pki/tls/certs/ca-bundle.crt
metadata_expire=300
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;安装&#34;&gt;安装&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;## Update Yum package metadata
yum update -y

## install the packages
## install these dependencies from standard OS repositories
yum install socat logrotate -y

yum install erlang rabbitmq-server -y
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;启动服务&#34;&gt;启动服务&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;## 所有节点
systemctl enable rabbitmq-server.service
systemctl start rabbitmq-server.service

## 主节点
拷贝 /var/lib/rabbitmq/.erlang.cookie 到副本节点

## 副本节点
rabbitmqctl stop_app # =&amp;gt; 停止节点 rabbit@rabbit2 ...完成。
rabbitmqctl reset # =&amp;gt; 重置节点 rabbit@rabbit2 ... 
rabbitmqctl join_cluster rabbit@rabbit1 # =&amp;gt; 使用 [rabbit@rabbit1] 聚类节点 rabbit@rabbit2 ...完成。
rabbitmqctl start_app # =&amp;gt; 开始节点 rabbit@rabbit2 ...完成。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;操作&#34;&gt;操作&lt;/h4&gt;
&lt;h5 id=&#34;创建vhost&#34;&gt;创建vhost&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;rabbitmqctl add_vhost qa1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;创建用户&#34;&gt;创建用户&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;rabbitmqctl add_user &amp;quot;username&amp;quot; &amp;quot;password&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;用户授权&#34;&gt;用户授权&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;rabbitmqctl set_permissions -p &amp;quot;qa1&amp;quot; &amp;quot;iie&amp;quot; &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;启用ui&#34;&gt;启用UI&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;## Enable
rabbitmq-plugins enable rabbitmq_management

## tag the user with &amp;quot;administrator&amp;quot; for full management UI and HTTP API access
rabbitmqctl set_user_tags full_access administrator

## Access http://{node-hostname}:15672/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Kafka</title>
      <link>/posts/kafka/</link>
      <pubDate>Tue, 09 Feb 2021 13:32:56 +0800</pubDate>
      <guid>/posts/kafka/</guid>
      <description>&lt;p&gt;Kafka&lt;/p&gt;
&lt;h3 id=&#34;维护&#34;&gt;维护&lt;/h3&gt;
&lt;h4 id=&#34;查看所有consumer&#34;&gt;查看所有consumer&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kafka-consumer-groups.sh  --list --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;查看offset&#34;&gt;查看offset&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kafka-consumer-offset-checker.sh --group SampleConsumer --topic topicName  --zookeeper localhost:2181
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;重置offset&#34;&gt;重置offset&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group SampleConsumer --reset-offsets --to-earliest --topic topicName --execute
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>IDEA</title>
      <link>/posts/idea/</link>
      <pubDate>Mon, 08 Feb 2021 17:15:34 +0800</pubDate>
      <guid>/posts/idea/</guid>
      <description>&lt;p&gt;IDEA&lt;/p&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
&lt;h4 id=&#34;控制台乱码&#34;&gt;控制台乱码&lt;/h4&gt;
&lt;p&gt;Help-&amp;gt;Edit Custom VM Options&amp;hellip;，添加-Dfile.encoding=UTF-8&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ELK</title>
      <link>/posts/elk/</link>
      <pubDate>Mon, 18 Jan 2021 11:33:05 +0800</pubDate>
      <guid>/posts/elk/</guid>
      <description>&lt;p&gt;ELK&lt;/p&gt;
&lt;h3 id=&#34;docker-compose方式部署&#34;&gt;Docker Compose方式部署&lt;/h3&gt;
&lt;p&gt;采集docker容器日志&lt;/p&gt;
&lt;h4 id=&#34;目录结构&#34;&gt;目录结构&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;.
├── docker-compose.yml
├── filebeat.yml
└── pipeline
    └── logstash.conf

1 directory, 3 files
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;docker-composeyml&#34;&gt;docker-compose.yml&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3.3&#39;
services:

  elasticsearch:
    hostname: elasticsearch
    image: docker.elastic.co/elasticsearch/elasticsearch:$ELASTIC_VERSION
    environment:
      - TZ=Asia/Shanghai
      - bootstrap.memory_lock=true
      - &amp;quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&amp;quot;
      - discovery.type=single-node
    volumes:
      - esdata1:/usr/share/elasticsearch/data
    ports:
      - 9200:9200
    networks:
      - stack

  kibana:
    hostname: kibana
    image: docker.elastic.co/kibana/kibana:$ELASTIC_VERSION
    environment:
      - TZ=Asia/Shanghai
    depends_on:
      - elasticsearch
    ports:
      - 5601:5601
    networks:
      - stack

  logstash:
    hostname: logstash
    image: docker.elastic.co/logstash/logstash:$ELASTIC_VERSION
    environment:
      - TZ=Asia/Shanghai
    volumes:
      - ./pipeline/:/usr/share/logstash/pipeline/
    ports:
      - 5044:5044
    depends_on:
      - elasticsearch
    networks:
      - stack

  filebeat:
    hostname: filebeat
    image: docker.elastic.co/beats/filebeat:${ELASTIC_VERSION}
    environment:
      - TZ=Asia/Shanghai
    user: root
    volumes:
      - ./filebeat.yml:/usr/share/filebeat/filebeat.yml:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
    command: filebeat -e
    depends_on:
      - elasticsearch
      - kibana
    restart: on-failure
    networks:
      - stack

volumes:
  esdata1:
    driver: local
networks:
  stack:
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;filebeatyml&#34;&gt;filebeat.yml&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;filebeat.autodiscover:
  providers:
    - type: docker
      templates:
        - condition:
            contains:
              docker.container.labels.com.docker.compose.project.working_dir: metasearch
          config:
            - type: container
              paths:
                - /var/lib/docker/containers/${data.docker.container.id}/*.log
              multiline.pattern: &#39;^([0-9]{4}-[0-9]{2}-[0-9]{2})&#39;
              multiline.negate: true
              multiline.match: after

output.logstash:
  hosts: [&amp;quot;logstash:5044&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;logstashconf&#34;&gt;logstash.conf&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;input {
  beats {
    port =&amp;gt; 5044
  }
}

filter {
  grok {
    match =&amp;gt; {
      &amp;quot;message&amp;quot; =&amp;gt; [
        &amp;quot;(?m)%{TIMESTAMP_ISO8601:timestamp}%{SPACE}%{LOGLEVEL:level} %{NUMBER} --- \[\s*%{DATA:thread}\] [A-Za-z0-9.]*\.(?&amp;lt;class&amp;gt;[A-Za-z0-9#_$]+)\s*:\s+%{GREEDYDATA:logmessage}&amp;quot;,
        &amp;quot;(?m)%{TIMESTAMP_ISO8601:timestamp}%{SPACE}%{LOGLEVEL:level} \[%{DATA:thread}\][A-Za-z0-9.]*\.(?&amp;lt;class&amp;gt;[A-Za-z0-9#_$]+)\.(?&amp;lt;method&amp;gt;[A-Za-z0-9#_$&amp;lt;&amp;gt;]+):%{NUMBER:line} -%{GREEDYDATA:logmessage}&amp;quot;
      ]
    }
  }
  date {
    match =&amp;gt; [&amp;quot;timestamp&amp;quot;, &amp;quot;ISO8601&amp;quot;, &amp;quot;yyyy-MM-dd HH:mm:ss.SSS&amp;quot;]
  }
  mutate {
    remove_field =&amp;gt; [&amp;quot;docker&amp;quot;, &amp;quot;container&amp;quot;, &amp;quot;agent&amp;quot;, &amp;quot;ecs&amp;quot;, &amp;quot;stream&amp;quot;]
    add_field =&amp;gt; {
      &amp;quot;service&amp;quot; =&amp;gt; &amp;quot;%{[docker][container][labels][com_docker_compose_service]}&amp;quot;
    }
  }
}

output {
  elasticsearch {
    hosts =&amp;gt; [&amp;quot;http://elasticsearch:9200&amp;quot;]
    index =&amp;gt; &amp;quot;metasearch-log-%{+YYYY.MM.dd}&amp;quot; 
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>MinIO安装</title>
      <link>/posts/minio/</link>
      <pubDate>Fri, 25 Sep 2020 11:08:58 +0800</pubDate>
      <guid>/posts/minio/</guid>
      <description>&lt;p&gt;MinIO&lt;/p&gt;
&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;wget https://dl.min.io/server/minio/release/linux-amd64/minio -O /usr/local/bin/minio
chmod +x /usr/local/bin/minio
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;环境变量&#34;&gt;环境变量&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;export MINIO_ACCESS_KEY=&amp;lt;ACCESS_KEY&amp;gt;
export MINIO_SECRET_KEY=&amp;lt;SECRET_KEY&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;单节点&#34;&gt;单节点&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;minio server /data
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;分布式&#34;&gt;分布式&lt;/h4&gt;
&lt;h5 id=&#34;单节点多磁盘&#34;&gt;单节点多磁盘&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;minio server /data{1...4}
or
minio server /data1 /data2 /data3 /data4

# 后台运行
setsid minio server /home/minio/data &amp;gt;/home/minio/data/minio.log 2&amp;gt;&amp;amp;1 &amp;lt; /dev/null &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;多节点多磁盘&#34;&gt;多节点多磁盘&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;minio server http://host{1...n}/export{1...m}
or
minio server http://host1/export1 http://host1/export2 http://host2/export1 http://host2/export2 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有运行分布式 MinIO 的节点需要具有相同的访问密钥和秘密密钥才能连接。为了实现这一点，建议在执行 MINIO 服务器命令之前，将所有节点上的访问密钥和秘密密钥作为环境变量 MINIO _ access _ key 和 MINIO _ secret _ key 导出。&lt;/li&gt;
&lt;li&gt;分布式 Minio 使用的磁盘里必须是干净的，里面没有数据。&lt;/li&gt;
&lt;li&gt;MinIO 创建每组4到16个驱动器的擦除编码集。您提供的驱动器总数必须是这些数字之一的倍数。&lt;/li&gt;
&lt;li&gt;_ MinIO 选择最大的 EC 设置大小，将其划分为驱动器的总数或给定的节点的总数——确保保持均匀分布，即每个节点参与每个设置的驱动器数相等。&lt;/li&gt;
&lt;li&gt;建议所有运行分布式 MinIO 设置的节点都是同构的，即相同的操作系统、相同数量的磁盘和相同的网络互连。&lt;/li&gt;
&lt;li&gt;运行分布式 MinIO 实例的服务器时间差不应超过15分钟。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;服务&#34;&gt;服务&lt;/h4&gt;
&lt;h5 id=&#34;单节点-1&#34;&gt;单节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useradd minio
passwd minio
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建默认配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOT &amp;gt;&amp;gt; /etc/default/minio
# Volume to be used for MinIO server.
MINIO_VOLUMES=&amp;quot;/tmp/minio/&amp;quot;
# Use if you want to run MinIO on a custom port.
MINIO_OPTS=&amp;quot;--address :9199&amp;quot;
# Access Key of the server.
MINIO_ACCESS_KEY=Server-Access-Key
# Secret key of the server.
MINIO_SECRET_KEY=Server-Secret-Key
   
EOT
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载 service 文件 &lt;a href=&#34;https://raw.githubusercontent.com/minio/minio-service/master/linux-systemd/minio.service&#34;&gt;https://raw.githubusercontent.com/minio/minio-service/master/linux-systemd/minio.service&lt;/a&gt; 到 /etc/systemd/system/，&lt;strong&gt;并替换里面的用户和组&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=MinIO
Documentation=https://docs.min.io
Wants=network-online.target
After=network-online.target
AssertFileIsExecutable=/usr/local/bin/minio
   
[Service]
WorkingDirectory=/usr/local/
   
User=minio-user
Group=minio-user
   
EnvironmentFile=/etc/default/minio
ExecStartPre=/bin/bash -c &amp;quot;if [ -z \&amp;quot;${MINIO_VOLUMES}\&amp;quot; ]; then echo \&amp;quot;Variable MINIO_VOLUMES not set in /etc/default/minio\&amp;quot;; exit 1; fi&amp;quot;
   
ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES
   
# Let systemd restart this service always
Restart=always
   
# Specifies the maximum file descriptor number that can be opened by this process
LimitNOFILE=65536
   
# Disable timeout logic and wait until process is stopped
TimeoutStopSec=infinity
SendSIGKILL=no
   
[Install]
WantedBy=multi-user.target
   
# Built for ${project.name}-${project.version} (${project.name})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl daemon-reload
systemctl start minio
systemctl enable minio
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;分布式-1&#34;&gt;分布式&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useradd minio
passwd minio
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建存储目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir /export
sudo chown -R minio /export &amp;amp;&amp;amp; sudo chmod u+rxw /export
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建默认配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOT &amp;gt;&amp;gt; /etc/default/minio
# Remote volumes to be used for MinIO server.
MINIO_VOLUMES=http://node{1...6}/export{1...32}
# Use if you want to run MinIO on a custom port.
MINIO_OPTS=&amp;quot;--address :9199&amp;quot;
# Access Key of the server.
MINIO_ACCESS_KEY=Server-Access-Key
# Secret key of the server.
MINIO_SECRET_KEY=Server-Secret-Key
   
EOT
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载 service 文件 &lt;a href=&#34;https://raw.githubusercontent.com/minio/minio-service/master/linux-systemd/distributed/minio.service&#34;&gt;https://raw.githubusercontent.com/minio/minio-service/master/linux-systemd/distributed/minio.service&lt;/a&gt; 到 /etc/systemd/system/，&lt;strong&gt;并替换里面的用户和组&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=MinIO
Documentation=https://docs.min.io
Wants=network-online.target
After=network-online.target
AssertFileIsExecutable=/usr/local/bin/minio
   
[Service]
WorkingDirectory=/usr/local
   
User=minio-user
Group=minio-user
   
EnvironmentFile=-/etc/default/minio
ExecStartPre=/bin/bash -c &amp;quot;if [ -z \&amp;quot;${MINIO_VOLUMES}\&amp;quot; ]; then echo \&amp;quot;Variable MINIO_VOLUMES not set in /etc/default/minio\&amp;quot;; exit 1; fi&amp;quot;
ExecStartPre=/bin/bash -c &amp;quot;if [ -z \&amp;quot;${MINIO_ACCESS_KEY}\&amp;quot; ]; then echo \&amp;quot;Variable MINIO_ACCESS_KEY not set in /etc/default/minio\&amp;quot;; exit 1; fi&amp;quot;
ExecStartPre=/bin/bash -c &amp;quot;if [ -z \&amp;quot;${MINIO_SECRET_KEY}\&amp;quot; ]; then echo \&amp;quot;Variable MINIO_SECRET_KEY not set in /etc/default/minio\&amp;quot;; exit 1; fi&amp;quot;
   
ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES
   
# Let systemd restart this service always
Restart=always
   
# Specifies the maximum file descriptor number that can be opened by this process
LimitNOFILE=65536
   
# Disable timeout logic and wait until process is stopped
TimeoutStopSec=infinity
SendSIGKILL=no
   
[Install]
WantedBy=multi-user.target
   
# Built for ${project.name}-${project.version} (${project.name})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl daemon-reload
systemctl start minio
systemctl enable minio
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;客户端&#34;&gt;客户端&lt;/h4&gt;
&lt;h5 id=&#34;安装-1&#34;&gt;安装&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;wget https://dl.min.io/client/mc/release/linux-amd64/mc -O /usr/local/bin/mc
chmod +x /usr/local/bin/mc
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;常用命令&#34;&gt;常用命令&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ls&lt;/td&gt;
&lt;td&gt;list buckets and objects&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;挂载minio为本地路径&#34;&gt;挂载minio为本地路径&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装goofys&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install -y fuse
wget https://github.com/kahing/goofys/releases/latest/download/goofys -P /usr/local/bin/
chmod +x /usr/local/bin/goofys
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置认证信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir ~/.aws
$ cat &amp;lt;&amp;lt;EOT &amp;gt; ~/.aws/credentials
[default]
aws_access_key_id=Server-Access-Key
aws_secret_access_key=Server-Secret-Key
EOT
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;goofys &amp;lt;bucket&amp;gt; &amp;lt;mountpoint&amp;gt;
goofys &amp;lt;bucket:prefix&amp;gt; &amp;lt;mountpoint&amp;gt; # if you only want to mount objects under a prefix
   
# 示例
goofys --endpoint http://10.111.54.230:9000 test /minio-local-data
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开机自动挂载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改 /etc/fstab, 添加如下内容
goofys#bucket /mnt/mountpoint fuse _netdev,allow_other,--file-mode=0666,--dir-mode=0777 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;卸载&#34;&gt;卸载&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;fusermount -u /path/to/mountpoint
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;定时删除文件&#34;&gt;定时删除文件&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;## 每天2点，删除30天前的文件
0 2 * * * /root/minio-binaries/mc rm --recursive --dangerous --force --older-than 30d local
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>/posts/linux/</link>
      <pubDate>Wed, 23 Sep 2020 16:08:58 +0800</pubDate>
      <guid>/posts/linux/</guid>
      <description>&lt;p&gt;Linux - CentOS&lt;/p&gt;
&lt;h4 id=&#34;查看系统版本&#34;&gt;查看系统版本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/redhat-release
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;hostname&#34;&gt;hostname&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置 hostname&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo hostnamectl set-hostname newname
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 /etc/hosts&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;gt;&amp;gt; /etc/hosts &amp;lt;&amp;lt; EOF
192.168.1.100    domain1
192.168.1.101    domain2
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启networking&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl restart network
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;跟踪脚本&#34;&gt;跟踪脚本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;bash -x *.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;挂载光盘为本地源&#34;&gt;挂载光盘为本地源&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;挂载光盘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mount /dev/cdrom /mnt/cdrom
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置本地源文件CentOS-Media.repo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;baseurl修改第二个路径为上步的挂载点(/mnt/cdrom)
enabled=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁用默认的yum网络源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将yum 网络源配置文件改名为CentOS-Base.repo.bak,否则会先在网络源中寻找适合的包,改名之后直接从本地源读取.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;硬盘挂载及扩容&#34;&gt;硬盘挂载及扩容&lt;/h4&gt;
&lt;h5 id=&#34;新硬盘挂载&#34;&gt;新硬盘挂载&lt;/h5&gt;
&lt;p&gt;&lt;em&gt;参考：http://www.linuxidc.com/Linux/2012-07/65294.htm&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看硬盘分区情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo fdisk -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新硬盘分区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo fdisk /dev/sda
Command (m for help)
n：增加新分区
e：扩展分区
Partition number(1-4)：默认1,只分一个区
cylinder：默认
分区大小：默认
p：显示分区表
w：保存分区表
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看分区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;格式化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mkfs -t ext4 /dev/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂载目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mount -t ext4 /dev/sda /mnt/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开机自动挂载(编辑/etc/fstab)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在最后一行加入
/dev/sda1 /mnt/sda1 ext4 defaults 1 2
或者
UUID=37eaa526-5d96-4237-8468-603df5216ce9 /mnt/sda ext4 defaults 0 3
**UUID可以通过使用blkid命令来查看(sudo blkid /dev/sda)
**０表示不备份；１表示要将整个&amp;lt;file system&amp;gt;中的内容备份。此处建议设置为０。
**０表示不检查；挂载点为分区／（根分区）必须设置为１，其他的挂载点不能设置为１
分区      挂载目录 文件格式
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;新硬盘扩容根节点&#34;&gt;新硬盘扩容根节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看硬盘分区情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo fdisk -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建物理卷&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pvcreate /dev/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看创建好的物理卷&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pvdisplay /dev/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卷组扩容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vgextend gafis70-vg /dev/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看扩容之后的卷组信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vgdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑卷扩容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 指定大小
lvextend -l +8G /dev/gafis-vg/root
# 全部
lvextend -l +100%free /dev/gafis-vg/root
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看扩容之后的逻辑卷&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lvdisplay /dev/gafis-vg/root
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件系统扩容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;resize2fs /dev/mapper/gafis--vg-root
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;ssh&#34;&gt;ssh&lt;/h4&gt;
&lt;h5 id=&#34;免密&#34;&gt;免密&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生成密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将公钥追加到认证文件中(本机免密)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat ~/.ssh/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将公钥追加到其他机器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-copy-id root@remote_ip
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;免密2&#34;&gt;免密2&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生成密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;pass&amp;quot;
文件名: 回车
密码: pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将公钥追加到其他机器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-copy-id root@remote_ip
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ssh-agent&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-agent bash
ssh-add .ssh/id_rsa
输入密码
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;防火墙&#34;&gt;防火墙&lt;/h4&gt;
&lt;p&gt;&amp;ndash; firewalld默认开放ssh服务, 默认规则都添加到zone=public
参数
&amp;ndash;zone #作用域
&amp;ndash;add-port=80/tcp #添加端口，格式为：端口/通讯协议
&amp;ndash;permanent #永久生效，没有此参数重启后失效&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开放http(80)服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --add-service=http
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久开放http服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --add-service=http --permanent
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --remove-service=http --permanent
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启防火墙生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 所有
firewall-cmd --list-all
# 端口
firewall-cmd --list-ports
# 服务
firewall-cmd --list-services
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询服务启用状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --query-service http
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久开放端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --add-port=3128/tcp --permanent
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ulimit最大进程数和最大文件打开数&#34;&gt;ulimit（最大进程数和最大文件打开数)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 最大文件打开数
ulimit -n
# 最大进程数
ulimit -u
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时修改（重启后失效）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ulimit -n 204800
ulimit -u 204800
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久修改，修改 /etc/security/limits.conf 文件，在文件末尾添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* soft nofile 204800
* hard nofile 204800
* soft nproc 204800
* hard nproc 204800
    
*          代表针对所有用户 
noproc     是代表最大进程数 
nofile     是代表最大文件打开数
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;*   soft    nofile  65535&amp;quot; &amp;gt;&amp;gt; /etc/security/limits.conf
echo &amp;quot;*   hard    nofile  65535&amp;quot; &amp;gt;&amp;gt; /etc/security/limits.conf
echo &amp;quot;*   soft    nproc  65535&amp;quot; &amp;gt;&amp;gt; /etc/security/limits.conf
echo &amp;quot;*   hard    nproc  65535&amp;quot; &amp;gt;&amp;gt; /etc/security/limits.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;vmmax_map_count&#34;&gt;vm.max_map_count&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl -a | grep vm.max_map_count
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时修改（重启后失效）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl -w vm.max_map_count=262144
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久修改，修改 /etc/sysctl.conf 文件，在文件末尾添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vm.max_map_count=262144
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl -p
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;后台守护进程&#34;&gt;后台守护进程&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;setsid myscript.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
# 输出到日志文件
setsid myscript.sh &amp;gt;/path/to/logfile 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;swap&#34;&gt;swap&lt;/h4&gt;
&lt;h5 id=&#34;添加swap分区&#34;&gt;添加swap分区&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# 添加8G的swap分区
dd if=/dev/zero of=/home/swap bs=1024 count=8388608
mkswap /home/swap
swapon /home/swap
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;禁用swap&#34;&gt;禁用swap&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;sudo swapoff -a
sudo sed -i &#39;/ swap / s/^\(.*\)$/#\1/g&#39; /etc/fstab
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;禁用selinux&#34;&gt;禁用SELinux&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sestatus
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo setenforce 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed -i &#39;s/enforcing/disabled/g&#39; /etc/selinux/config /etc/selinux/config
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;监控文件夹&#34;&gt;监控文件夹&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;watch -n 0.1 ls &amp;lt;your_folder&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;查看cpu个数&#34;&gt;查看CPU个数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;## 方法1
grep -c ^processor /proc/cpuinfo
## 方法2
nproc
## 方法3
getconf _NPROCESSORS_ONLN
## 方法4
lscpu | grep &#39;CPU(s):&#39; | head -1 | awk &#39;{print $2}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;代理上网&#34;&gt;代理上网&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;## /etc/profile
export http_proxy=&amp;quot;http://proxy_username:proxy_password@proxy_ip:proxy_port&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;laquo;&amp;laquo;&amp;laquo;&amp;lt; HEAD&lt;/p&gt;
&lt;h4 id=&#34;目录结构查看&#34;&gt;目录结构查看&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;## 目录
ls -R | grep &amp;quot;:$&amp;quot; | sed -e &#39;s/:$//&#39; -e &#39;s/[^-][^\/]*\//--/g&#39; -e &#39;s/^/   /&#39; -e &#39;s/-/|/&#39;
## 文件
find . | sed -e &amp;quot;s/[^-][^\/]*\//  |/g&amp;quot; -e &amp;quot;s/|\([^ ]\)/|-\1/&amp;quot;
=======
#### 查看PID进程详情

&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;cat /proc/PID/cmdline | tr &amp;lsquo;\000&amp;rsquo; &#39; &#39;&lt;/li&gt;
&lt;li&gt;cat /proc/PID/cmdline | xargs -0 echo&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;a7ccb4a03d0b7eceeed9fc13f3c0ac57061f88ad&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>/posts/redis/</link>
      <pubDate>Tue, 01 Sep 2020 17:11:11 +0800</pubDate>
      <guid>/posts/redis/</guid>
      <description>&lt;h4 id=&#34;redis-cluster&#34;&gt;Redis Cluster&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注：建议6个节点。在没有6个节点的情况下，每个节点可以创建2个实例&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载安装包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget http://download.redis.io/releases/redis-5.0.5.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar zxf redis-5.0.5.tar.gz -C /opt/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum -y install gcc-c++
cd /opt/redis-5.0.5/ &amp;amp;&amp;amp; make MALLOC=libc
./utils/install_server.sh
# 1 Please select the redis port for this instance: [6379] -- 
# 2 Please select the redis config file name [/etc/redis/6379.conf] --
# 3 Please select the redis log file name [/var/log/redis_6379.log] --
# 4 Please select the data directory for this instance [/var/lib/redis/6379] --
# 5 Please select the redis executable path [] -- /opt/redis-5.0.5/src/redis-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置 /etc/redis/6379.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 绑定地址
bind 0.0.0.0
# 端口
port 6379
# 安全密码
requirepass foobared
## =========集群相关=========
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000
appendonly yes
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl restart redis_6379
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建集群&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 3个主节点, 3个副本节点
redis-cli --cluster create 192.168.201.101:6379 192.168.201.101:6380 192.168.201.102:6379 192.168.201.102:6380 192.168.201.103:6379 192.168.201.103:6380 -a foobared --cluster-replicas 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建别名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改 ~/.bashrc，添加如下内容
alias redis-cli=/opt/redis-5.0.5/src/redis-cli
alias redis-server=/opt/redis-5.0.5/src/redis-server
# 生效
source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Goofys挂载minio为本地路径</title>
      <link>/posts/minio/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Fri, 12 Jun 2020 14:38:16 +0800</pubDate>
      <guid>/posts/minio/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</guid>
      <description>&lt;p&gt;goofys 挂载 minio 为本地路径&lt;/p&gt;
&lt;h4 id=&#34;goofys&#34;&gt;goofys&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/kahing/goofys/releases/latest/download/goofys -P /usr/local/bin/
chmod +x /usr/local/bin/goofys
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置认证信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat ~/.aws/credentials
[default]
aws_access_key_id = AKID1234567890
aws_secret_access_key = MY-SECRET-KEY
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;挂载minio&#34;&gt;挂载minio&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;挂载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;goofys &amp;lt;bucket&amp;gt; &amp;lt;mountpoint&amp;gt;
goofys &amp;lt;bucket:prefix&amp;gt; &amp;lt;mountpoint&amp;gt; # if you only want to mount objects under a prefix
   
# 示例
goofys --endpoint http://10.111.54.230:9000 test /minio-local-data
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开机自动挂载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改 /etc/fstab, 添加如下内容
goofys#bucket /mnt/mountpoint fuse _netdev,allow_other,--file-mode=0666,--dir-mode=0777 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装minio</title>
      <link>/posts/minio/kubernetes%E5%AE%89%E8%A3%85minio/</link>
      <pubDate>Fri, 12 Jun 2020 13:48:12 +0800</pubDate>
      <guid>/posts/minio/kubernetes%E5%AE%89%E8%A3%85minio/</guid>
      <description>&lt;p&gt;通过 helm 在 kubernetes 上安装 minio&lt;/p&gt;
&lt;h4 id=&#34;前提&#34;&gt;前提&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;3台服务器，CentOS7 系统&lt;/li&gt;
&lt;li&gt;已安装Kubernetes环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;安装helm3&#34;&gt;安装helm3&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载安装包 &lt;a href=&#34;https://github.com/helm/helm/releases&#34;&gt;https://github.com/helm/helm/releases&lt;/a&gt;，选择 Linux amd64 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf helm-v3.0.0-linux-amd64.tar.gz
mv linux-amd64/helm /usr/local/bin/helm
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加仓库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm repo add stable https://kubernetes-charts.storage.googleapis.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;安装kubeapps&#34;&gt;安装kubeapps&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm repo add bitnami https://charts.bitnami.com/bitnami
kubectl create namespace kubeapps
helm install kubeapps --namespace kubeapps bitnami/kubeapps --set useHelm3=true
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 Kubernetes API token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create serviceaccount kubeapps-operator
kubectl create clusterrolebinding kubeapps-operator --clusterrole=cluster-admin --serviceaccount=default:kubeapps-operator
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret $(kubectl get serviceaccount kubeapps-operator -o jsonpath=&#39;{range .secrets[*]}{.name}{&amp;quot;\n&amp;quot;}{end}&#39; | grep kubeapps-operator-token) -o jsonpath=&#39;{.data.token}&#39; -o go-template=&#39;{{.data.token | base64decode}}&#39; &amp;amp;&amp;amp; echo
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启 Dashboard&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl port-forward -n kubeapps --address 0.0.0.0 svc/kubeapps 8080:80
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;创建minio-pv&#34;&gt;创建minio PV&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 StorageClass&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage-minio
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 minio 需要的 PV&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里在 k8s的2个 worker 节点上创建了4个pv，因为minio分布式最少需要4个节点，所里这里在2个worker节点上分别创建了2个存储目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-minio-0
spec:
  capacity:
    storage: 2Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-minio
  local:
    path: /localdata/minio/data-0
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node2
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-minio-1
spec:
  capacity:
    storage: 2Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-minio
  local:
    path: /localdata/minio/data-1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node2
---
   
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-minio-2
spec:
  capacity:
    storage: 2Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-minio
  local:
    path: /localdata/minio/data-2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-minio-3
spec:
  capacity:
    storage: 2Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-minio
  local:
    path: /localdata/minio/data-3
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动创建PV目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# node2
mkdir -p /localdata/minio/data-0
mkdir -p /localdata/minio/data-1
   
# node3
mkdir -p /localdata/minio/data-2
mkdir -p /localdata/minio/data-3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;kubeapps-部署-minio&#34;&gt;kubeapps 部署 minio&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;搜索 Chart，选择 bitnami 仓库的 Chart&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-catalog-minio.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-deploy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-submit-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改Values的一些属性&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;原始值&lt;/th&gt;
&lt;th&gt;新值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mode&lt;/td&gt;
&lt;td&gt;standalone&lt;/td&gt;
&lt;td&gt;distributed&lt;/td&gt;
&lt;td&gt;集群模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resources.requests&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;requests:&lt;br/&gt;    cpu: 250m&lt;br/&gt;    memory: 256Mi&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;persistence.size&lt;/td&gt;
&lt;td&gt;8Gi&lt;/td&gt;
&lt;td&gt;1Gi&lt;/td&gt;
&lt;td&gt;该值修改为 minio PV 的一半，如果设置成一样大，有可能出现自动创建的 PVC 无法绑定的情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;persistence.storageClass&lt;/td&gt;
&lt;td&gt;&amp;ldquo;-&amp;rdquo;&lt;/td&gt;
&lt;td&gt;local-storage-minio&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;networkPolicy.enabled&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;networkPolicy.allowExternal&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;具体参数请参考官方文档：https://github.com/bitnami/charts/tree/master/bitnami/minio&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击下方的 Submit 按钮提交&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-submit-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待部署完成，即4个Pod都Ready的时候&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-detail.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启minio WebUI&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl port-forward --address 0.0.0.0 svc/minio 9000:9000
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;minio-webui.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;账号密码可以通过minio 详情页面查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-key-secret.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes</title>
      <link>/posts/kubernetes/kubernetes/</link>
      <pubDate>Tue, 09 Jun 2020 18:36:00 +0800</pubDate>
      <guid>/posts/kubernetes/kubernetes/</guid>
      <description>&lt;p&gt;kubernets&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;h4 id=&#34;准备工作&#34;&gt;准备工作&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开启防火墙端口&lt;/p&gt;
&lt;p&gt;需要开启的端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Master node(s):
   
TCP     6443*       Kubernetes API Server
TCP     2379-2380   etcd server client API
UDP     8472        flannel only
TCP     10250       Kubelet API
TCP     10251       kube-scheduler
TCP     10252       kube-controller-manager
TCP     10255       Read-Only Kubelet API
   
Worker nodes (minions):
   
UDP     8472        flannel only
TCP     10250       Kubelet API
TCP     10255       Read-Only Kubelet API
TCP     30000-32767 NodePort Services
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# 主节点
firewall-cmd --permanent --add-port=6443/tcp
firewall-cmd --permanent --add-port=2379-2380/tcp
firewall-cmd --permanent --add-port=10250/tcp
firewall-cmd --permanent --add-port=10251/tcp
firewall-cmd --permanent --add-port=10252/tcp
firewall-cmd --permanent --add-port=10255/tcp
firewall-cmd --permanent --add-port=8472/udp
firewall-cmd --add-masquerade --permanent
# only if you want NodePorts exposed on control plane IP as well
firewall-cmd --permanent --add-port=30000-32767/tcp
systemctl restart firewalld
   
# 从节点
firewall-cmd --permanent --add-port=10250/tcp
firewall-cmd --permanent --add-port=10255/tcp
firewall-cmd --permanent --add-port=8472/udp
firewall-cmd --permanent --add-port=30000-32767/tcp
firewall-cmd --add-masquerade --permanent
systemctl restart firewalld
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置hostname&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 节点1
# 设置hostname
sudo hostnamectl set-hostname node1
# 修改/etc/hosts, 添加以下信息
192.168.201.120 node1
192.168.201.121 node2
192.168.201.122 node3
   
# 节点2
# 设置hostname
sudo hostnamectl set-hostname node2
# 修改/etc/hosts, 添加以下信息
192.168.201.120 node1
192.168.201.121 node2
192.168.201.122 node3
   
# 节点3
# 设置hostname
sudo hostnamectl set-hostname node3
# 修改/etc/hosts, 添加以下信息
192.168.201.120 node1
192.168.201.121 node2
192.168.201.122 node3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 安装docker仓库
yum install -y yum-utils
yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
# 安装docker 19.03 版本
yum install -y docker-ce-19.03.11 docker-ce-cli-19.03.11 containerd.io
# 安装最新版本
#yum install -y docker-ce docker-ce-cli containerd.io
# 启动docker
systemctl enable docker &amp;amp;&amp;amp; systemctl start docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置必需的sysctl参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl net.bridge.bridge-nf-call-iptables=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁用swap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo swapoff -a
sudo sed -i &#39;/ swap / s/^\(.*\)$/#\1/g&#39; /etc/fstab
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;kubernetes-程序安装&#34;&gt;Kubernetes 程序安装&lt;/h4&gt;
&lt;h5 id=&#34;在线安装方式&#34;&gt;在线安装方式&lt;/h5&gt;
&lt;h6 id=&#34;kubeletkubeadmkubectl&#34;&gt;kubelet/kubeadm/kubectl&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
# 开启kubelet
systemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;镜像&#34;&gt;镜像&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 预先拉去镜像
kubeadm config images pull
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;离线安装方式&#34;&gt;离线安装方式&lt;/h5&gt;
&lt;h6 id=&#34;下载程序包翻墙&#34;&gt;下载程序包(翻墙)&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 下载程序
yum install -y --downloadonly kubelet kubeadm kubectl --disableexcludes=kubernetes
# 下载镜像
kubeadm config images pull
docker pull quay.io/coreos/flannel:v0.12.0-amd64
# 将镜像保存为tar文件
docker save ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;kubeletkubeadmkubectl-1&#34;&gt;kubelet/kubeadm/kubectl&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 将程序包拷贝到服务器上
# 进入rpm文件路径
yum -y install *.rpm
# 开启kubelet
systemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;镜像-1&#34;&gt;镜像&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 将kubernetes相关镜像拷贝到服务器上
# 进入镜像文件目录, 加载所有镜像
for i in `ls`; do docker load &amp;lt; $i; done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;离线文件下载地址(1.18版本)&lt;/p&gt;
&lt;h4 id=&#34;部署&#34;&gt;部署&lt;/h4&gt;
&lt;h5 id=&#34;主节点&#34;&gt;主节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# flannel
kubeadm init --pod-network-cidr=10.244.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置环境变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;root&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# /etc/profile 添加以下内容
export KUBECONFIG=/etc/kubernetes/admin.conf
# 立即生效
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常规用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置网络&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;从节点&#34;&gt;从节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加入集群&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 此命令从主节点init命令输出获得
kubeadm join 192.168.201.120:6443 --token z8clj6.i8u6s0deqsncftaz --discovery-token-ca-cert-hash sha256:a0cf54fda227bb64d6af37479ed055aad31e55df287566d3793825705355f3d8
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;检查状态ready&#34;&gt;检查状态(Ready)&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# 主节点执行
kubectl get nodes
# 输出如下
NAME    STATUS     ROLES    AGE   VERSION
node1   Ready      master   21m   v1.18.3
node2   NotReady   &amp;lt;none&amp;gt;   37s   v1.18.3
node3   NotReady   &amp;lt;none&amp;gt;   36s   v1.18.3
# 等待一会, 全部Ready
NAME    STATUS   ROLES    AGE     VERSION
node1   Ready    master   22m     v1.18.3
node2   Ready    &amp;lt;none&amp;gt;   2m25s   v1.18.3
node3   Ready    &amp;lt;none&amp;gt;   2m24s   v1.18.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;dashboard&#34;&gt;Dashboard&lt;/h4&gt;
&lt;h5 id=&#34;外部访问&#34;&gt;外部访问&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Dashboard 服务类型 由 &lt;strong&gt;ClusterIP&lt;/strong&gt; 改为 &lt;strong&gt;NodePort&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n kube-system edit service kubernetes-dashboard
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 Admin Service Account&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl apply -f dashboard-adminuser.yml
serviceaccount/admin-user created
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 ClusterRoleBinding&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ kubectl apply -f admin-role-binding.yml
clusterrolebinding.rbac.authorization.k8s.io/admin-user created
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取 Token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &#39;{print $1}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;维护&#34;&gt;维护&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;删除Evicted状态Pod&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods | grep Evicted | awk &#39;{print $1}&#39; | xargs kubectl delete pod
# 指定命名空间
kubectl get pods -n ns | grep Evicted | awk &#39;{print $1}&#39; | xargs kubectl delete pod -n ns
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;问题&#34;&gt;问题&lt;/h4&gt;
&lt;h5 id=&#34;kubernetes-没有启动手动启动api-server-docker容器后出现错误消息error-response-from-daemon-cannot-join-network-of-a-non-running-container-56de51eee0b8e0a327c927889e198b84f65cccd8645a092823350c7c10e530af&#34;&gt;kubernetes 没有启动，手动启动api-server docker容器后出现错误消息：Error response from daemon: cannot join network of a non running container: 56de51eee0b8e0a327c927889e198b84f65cccd8645a092823350c7c10e530af&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;## 原因1
服务器时间不对，重新同步下时间（data -s &amp;quot;&amp;quot;）
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;plugin-flannel-does-not-support-config-version-&#34;&gt;[plugin flannel does not support config version &amp;quot;&amp;rdquo;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;## /etc/cni/net.d/10-flannel.conflist, 添加如下内容
{
  &amp;quot;cniVersion&amp;quot;: &amp;quot;0.3.1&amp;quot;,
  &amp;quot;name&amp;quot;: &amp;quot;cbr0&amp;quot;,
  ...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minikube安装</title>
      <link>/posts/minikube/</link>
      <pubDate>Mon, 08 Jun 2020 17:52:45 +0800</pubDate>
      <guid>/posts/minikube/</guid>
      <description>&lt;p&gt;Linux 安装minikube&lt;/p&gt;
&lt;h4 id=&#34;1-安装docker&#34;&gt;1 安装docker&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ curl -fsSL https://get.docker.com/ | sh
$ sudo systemctl start docker
$ sudo systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-创建用户&#34;&gt;2 创建用户&lt;/h4&gt;
&lt;p&gt;minikube 需要非root用户运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adduser developer
passwd developer
usermod -aG sudo developer
# 如果上面命令出现 usermod: group &#39;sudo&#39; does not exist, 运行以下命令
usermod -aG wheel developer
su - developer
sudo usermod -aG docker $USER
- 重新登录
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-安装kubectl&#34;&gt;3 安装kubectl&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
$ chmod +x ./kubectl
$ sudo mv ./kubectl /usr/local/bin/kubectl
$ kubectl version --client
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-安装minikube&#34;&gt;4 安装minikube&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \
  &amp;amp;&amp;amp; chmod +x minikube
$ sudo mkdir -p /usr/local/bin/
$ sudo install minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-启动minikube&#34;&gt;5 启动minikube&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 需要翻墙
minikube start --driver=docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6-验证安装&#34;&gt;6 验证安装&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;minikube status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Goofys挂载minio为本地路径</title>
      <link>/posts/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 08 Jun 2020 14:59:38 +0800</pubDate>
      <guid>/posts/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</guid>
      <description>&lt;p&gt;goofys挂载minio为本地路径&lt;/p&gt;
&lt;h4 id=&#34;1-安装fuse&#34;&gt;1 安装fuse&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;yum -y install fuse
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-安装goofys&#34;&gt;2 安装goofys&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/kahing/goofys/releases/latest/download/goofys -O /bin/goofys &amp;amp;&amp;amp; chmod +x /bin/goofys
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-配置认证信息&#34;&gt;3 配置认证信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ cat ~/.aws/credentials
[default]
aws_access_key_id = AKID1234567890
aws_secret_access_key = MY-SECRET-KEY
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-使用&#34;&gt;4 使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ $GOPATH/bin/goofys &amp;lt;bucket&amp;gt; &amp;lt;mountpoint&amp;gt;
$ $GOPATH/bin/goofys &amp;lt;bucket:prefix&amp;gt; &amp;lt;mountpoint&amp;gt;
# 例
goofys --endpoint http://localhost:9000 bucket /mnt
# 前端运行
goofys -f --endpoint http://localhost:9000 bucket /mnt
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-开机自动挂载&#34;&gt;5 开机自动挂载&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 配置 /etc/fstab, 添加如下信息
goofys#bucket /mnt/mountpoint fuse _netdev,allow_other,--file-mode=0666,--dir-mode=0777,--endpoint=http://localhost:9000 0 0
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot整合elasticsearch和redis的问题</title>
      <link>/posts/springboot/</link>
      <pubDate>Fri, 22 May 2020 12:38:34 +0800</pubDate>
      <guid>/posts/springboot/</guid>
      <description>&lt;h2 id=&#34;spring-boot&#34;&gt;Spring Boot&lt;/h2&gt;
&lt;h4 id=&#34;https&#34;&gt;HTTPS&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生成证书&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keytool -genkeypair -alias alias_name -keyalg RSA -keysize 2048 -storetype PKCS12 -keystore alias_name.p12 -ext &amp;quot;SAN:c=DNS:localhost,IP:127.0.0.1&amp;quot; -validity 3650
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将证书放到resources目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;spring boot 配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server:
  port: 8443
  ssl:
    enabled: true
    key-alias: alias_name
    key-store-password: ******
    key-store: classpath:alias_name.p12
    key-store-type: PKCS12
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 自定义 RestTemplate
RestTemplate serverRestTemplateWith() {
        SSLContext sslContext = getSSLContext();
        SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory(sslContext);
        CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build();
        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient);
        factory.setConnectTimeout(30000);
        factory.setReadTimeout(30000);
        return new RestTemplate(factory);
    }
   
// 构建 SSLContext
SSLContext getSSLContext() {
        try {
            AppProperties appProperties = appContext.getAppProperties();
            return SSLContexts.custom()
                    .loadTrustMaterial(ResourceUtils.getFile(appProperties.getServerKeyStore()), appProperties.getServerKeyStorePassword().toCharArray())
                    // 跳过证书检查
//                    .loadTrustMaterial(null, (X509Certificate[] chain, String authType) -&amp;gt; true)
                    .build();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;生成证书&#34;&gt;生成证书&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;keytool -genkeypair -alias bc -keyalg RSA -keysize 2048 -storetype PKCS12 -keystore bc.p12 -ext &amp;quot;SAN:c=DNS:localhost,IP:127.0.0.1&amp;quot; -validity 3650
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;问题描述：availableProcessors is already set to [8], rejecting [8]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决：https://blog.csdn.net/busishenren/article/details/90478928&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;问题&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Helm安装Kfaka</title>
      <link>/posts/helm%E5%AE%89%E8%A3%85kfaka/</link>
      <pubDate>Tue, 19 May 2020 11:15:58 +0800</pubDate>
      <guid>/posts/helm%E5%AE%89%E8%A3%85kfaka/</guid>
      <description>&lt;p&gt;本文介绍如何使用 helm 安装 Kafka，使用本地存储的方式。&lt;/p&gt;
&lt;h4 id=&#34;1-配置-chart-仓库&#34;&gt;1 配置 chart 仓库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm repo add incubator http://storage.googleapis.com/kubernetes-charts-incubator
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-创建本地存储storageclass&#34;&gt;2 创建本地存储StorageClass&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f local-storage-class.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里绑定模式选择 WaitForFirstConsumer&lt;/p&gt;
&lt;p&gt;默认情况下，Immediate 模式指示在创建 PersistentVolumeClaim 之后发生卷绑定和动态配置。 对于拓扑受限且不能从集群中的所有节点全局访问的存储后端，persistentvolume 将在不知道 Pod 的调度需求的情况下进行绑定或提供。 这可能会导致不可调度的Pod。&lt;/p&gt;
&lt;p&gt;集群管理员可以通过指定 WaitForFirstConsumer 模式来解决这个问题，该模式将延迟 PersistentVolume 的绑定和配置，直到创建使用 PersistentVolumeClaim 的 Pod。 Persistentvolumes 将根据 Pod 的调度约束所指定的拓扑结构进行选择或配给。 这些因素包括但不限于资源需求、节点选择器、Pod关联性和反关联性、污染和耐受性。&lt;/p&gt;
&lt;p&gt;Local 通过预先创建的 PersistentVolume 绑定支持 WaitForFirstConsumer。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&#34;&gt;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/volumes/#local&#34;&gt;https://kubernetes.io/docs/concepts/storage/volumes/#local&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-创建kafka和zookeeper的persistentvolume&#34;&gt;3 创建Kafka和Zookeeper的PersistentVolume&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;创建Kafka的PV&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-kafka-0
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/kafka/data-0
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-kafka-1
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/kafka/data-1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-kafka-2
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/kafka/data-2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /localstorage/kafka/data-0
mkdir -p /localstorage/kafka/data-1
mkdir -p /localstorage/kafka/data-2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;创建Zookeeper的PV&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-zookeeper-0
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/zookeeper/data-0
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-zookeeper-1
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/zookeeper/data-1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-zookeeper-2
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/zookeeper/data-2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /localstorage/zookeeper/data-0
mkdir -p /localstorage/zookeeper/data-1
mkdir -p /localstorage/zookeeper/data-2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要在节点上手动创建下存储目录 ，Kubernetes不会自动创建它。&lt;/p&gt;
&lt;p&gt;使用本地卷时需要 PersistentVolume nodeAffinity。 它使 Kubernetes 调度程序能够将使用本地卷的 Pods 正确调度到正确的节点。&lt;/p&gt;
&lt;h4 id=&#34;4-部署kafka&#34;&gt;4 部署Kafka&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建value文件kafka-values.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;external:
  enabled: true
configurationOverrides:
  &amp;quot;advertised.listeners&amp;quot;: |-
    EXTERNAL://192.168.1.1:$((31090 + ${KAFKA_BROKER_ID}))
  &amp;quot;listener.security.protocol.map&amp;quot;: |-
    PLAINTEXT:PLAINTEXT,EXTERNAL:PLAINTEXT
persistence:
  storageClass: local-storage
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里开启外部访问，配置IP地址（第5行），集群任意节点均可，同时配置storageClass。其他更多配置看官方文档 &lt;a href=&#34;https://github.com/helm/charts/tree/master/incubator/kafka&#34;&gt;https://github.com/helm/charts/tree/master/incubator/kafka&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install kafka-dev -f kafka-values.yaml incubator/kafka
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-查看kafka版本&#34;&gt;5 查看Kafka版本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kubectl exec kafka-dev-0 -- ls /usr/share/java/kafka | grep kafka
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;问题&#34;&gt;问题&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;no persistent volumes available for this claim and no storage class is set&lt;/p&gt;
&lt;p&gt;可能原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;values.yaml 中的 persistence.size 属性大于 PV 中 storage 大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在PVC绑定PV时通常根据两个条件来绑定，一个是存储的大小，另一个就是访问模式。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zookeeper Cannot open channel to 1 at election&lt;/p&gt;
&lt;p&gt;可能原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动zookeeper的时候，上一次启动的数据没有删除（挂载PV目录）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Helm安装MySQL</title>
      <link>/posts/helm%E5%AE%89%E8%A3%85mysql/</link>
      <pubDate>Fri, 15 May 2020 17:37:27 +0800</pubDate>
      <guid>/posts/helm%E5%AE%89%E8%A3%85mysql/</guid>
      <description>&lt;p&gt;本文介绍如何使用 helm 安装 MySQL，使用本地存储的方式。&lt;/p&gt;
&lt;h4 id=&#34;1-创建storageclass&#34;&gt;1 创建StorageClass&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage-mysql
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里绑定模式选择 WaitForFirstConsumer&lt;/p&gt;
&lt;p&gt;默认情况下，Immediate 模式指示在创建 PersistentVolumeClaim 之后发生卷绑定和动态配置。 对于拓扑受限且不能从集群中的所有节点全局访问的存储后端，persistentvolume 将在不知道 Pod 的调度需求的情况下进行绑定或提供。 这可能会导致不可调度的Pod。&lt;/p&gt;
&lt;p&gt;集群管理员可以通过指定 WaitForFirstConsumer 模式来解决这个问题，该模式将延迟 PersistentVolume 的绑定和配置，直到创建使用 PersistentVolumeClaim 的 Pod。 Persistentvolumes 将根据 Pod 的调度约束所指定的拓扑结构进行选择或配给。 这些因素包括但不限于资源需求、节点选择器、Pod关联性和反关联性、污染和耐受性。&lt;/p&gt;
&lt;p&gt;Local 通过预先创建的 PersistentVolume 绑定支持 WaitForFirstConsumer。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&#34;&gt;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/volumes/#local&#34;&gt;https://kubernetes.io/docs/concepts/storage/volumes/#local&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-创建persistentvolume&#34;&gt;2 创建PersistentVolume&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-mysql
spec:
  capacity:
    storage: 10Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-mysql
  local:
    path: /db/mysql
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用本地卷时需要 PersistentVolume nodeAffinity。 它使 Kubernetes 调度程序能够将使用本地卷的 Pods 正确调度到正确的节点。&lt;/p&gt;
&lt;h4 id=&#34;3-在指定节点上创建存储目录&#34;&gt;3 在指定节点上创建存储目录&lt;/h4&gt;
&lt;p&gt;这里需要在节点 node3 上手动创建存储目录 /db/mysql，Kubernetes不会自动创建它。&lt;/p&gt;
&lt;h4 id=&#34;4-安装mysql&#34;&gt;4 安装MySQL&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm install my-mysql --set persistence.storageClass=local-storage-mysql stable/mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里设置 storageClassName 属性为上面创建的 StorageClass，其他可设置属性参看官方说明 &lt;a href=&#34;https://github.com/helm/charts/tree/master/stable/mysql#configuration&#34;&gt;https://github.com/helm/charts/tree/master/stable/mysql#configuration&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>/posts/docker/</link>
      <pubDate>Wed, 13 May 2020 17:56:03 +0800</pubDate>
      <guid>/posts/docker/</guid>
      <description>&lt;h3 id=&#34;dockercentos&#34;&gt;Docker(CentOS)&lt;/h3&gt;
&lt;h4 id=&#34;安装开发环境&#34;&gt;安装(开发环境)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;## 1 更新Yum
sudo yum update
## 2 添加docker仓库并安装docker
curl -fsSL https://get.docker.com/ | sh
## 3 启动docker
sudo systemctl start docker
sudo systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://geekflare.com/docker-installation-guide/&#34;&gt;https://geekflare.com/docker-installation-guide/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;卸载&#34;&gt;卸载&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;sudo yum remove -y docker-ce docker-ce-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修改存储位置&#34;&gt;修改存储位置&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;## 1 创建文件 /etc/docker/daemon.json, 内容如下
{
  &amp;quot;data-root&amp;quot;: &amp;quot;/mnt/newlocation&amp;quot;
}
## 2 重启docker
sudo systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除冗余数据&#34;&gt;删除冗余数据&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;docker system prune -a
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除所有none镜像&#34;&gt;删除所有none镜像&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;docker rmi $(docker images | awk &#39;/^&amp;lt;none&amp;gt;/ { print $3 }&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除所有容器&#34;&gt;删除所有容器&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;docker stop $(docker ps -q) &amp;amp; docker rm $(docker ps -aq)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dockerfile&#34;&gt;Dockerfile&lt;/h3&gt;
&lt;h4 id=&#34;时区&#34;&gt;时区&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;FROM alpine:3.6
RUN apk add --no-cache tzdata
ENV TZ Asia/Shanghai
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;examples&#34;&gt;examples&lt;/h4&gt;
&lt;h5 id=&#34;spring-boot&#34;&gt;Spring Boot&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;FROM openjdk:8-jre-alpine
RUN apk add --no-cache tzdata
ENV TZ Asia/Shanghai
WORKDIR /app
COPY springboot.jar /app
ENTRYPOINT [&amp;quot;java&amp;quot;, &amp;quot;-jar&amp;quot;, &amp;quot;springboot.jar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;docker-compose&#34;&gt;Docker Compose&lt;/h3&gt;
&lt;h4 id=&#34;mysql&#34;&gt;MySQL&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3.3&#39;
services:

  db:
    image: mysql:5.7
    restart: always
    ports:
      - &#39;3306:3306&#39;
    environment:
      MYSQL_ROOT_PASSWORD: 1qazXSW@
    volumes:
      - ./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql
      - db-data:/var/lib/mysql

volumes:
  db-data:
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Hugo Github Pages</title>
      <link>/posts/hugo-github-pages/</link>
      <pubDate>Wed, 13 May 2020 15:45:43 +0800</pubDate>
      <guid>/posts/hugo-github-pages/</guid>
      <description>&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;p&gt;1 在github上创建仓库&amp;lt;USERNAME&amp;gt;.github.io&lt;/p&gt;
&lt;p&gt;2 
&lt;a href=&#34;https://github.com/sourcethemes/academic-kickstart#fork-destination-box&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;fork&lt;/strong&gt;&lt;/a&gt; &lt;em&gt;Academic Kickstart&lt;/em&gt; 仓库，并clone到本地（替换你的用户名）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/&amp;lt;USERNAME&amp;gt;/academic-kickstart.git My_Website
cd My_Website
git submodule update --init --recursive
git submodule add -f -b master https://github.com/&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 将所有内容添加到本地 git 存储库，并将其推送到 GitHub 上的远程存储库:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;Initial commit&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 通过运行 Hugo 重新生成网站的 HTML 代码，并将 public 子模块上传到 GitHub:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo
cd public
git add .
git commit -m &amp;quot;Build website&amp;quot;
git push origin master
cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5 通过浏览器访问 https://&lt;USERNAME&gt;.github.io&lt;/p&gt;
&lt;h3 id=&#34;添加内容&#34;&gt;添加内容&lt;/h3&gt;
&lt;p&gt;1 创建文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo new posts/my-first-post.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 部署脚本 deploy.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh

# If a command fails then the deploy stops
set -e

printf &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m\n&amp;quot;

# Build the project.
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

# Go To Public folder
cd public

# Add changes to git.
git add .

# Commit changes.
msg=&amp;quot;rebuilding site $(date)&amp;quot;
if [ -n &amp;quot;$*&amp;quot; ]; then
	msg=&amp;quot;$*&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 更新网站&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./deploy.sh &amp;quot;Your optional commit message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://georgecushen.com/create-your-website-with-hugo/&#34;&gt;https://georgecushen.com/create-your-website-with-hugo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://sourcethemes.com/academic/docs/deployment/&#34;&gt;https://sourcethemes.com/academic/docs/deployment/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>/posts/issue%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/posts/issue%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;使用gitlab管理项目&#34;&gt;使用GitLab管理项目&lt;/h1&gt;
&lt;h2 id=&#34;为什么是-gitlab&#34;&gt;为什么是 GitLab？&lt;/h2&gt;
&lt;p&gt;GitLab 不仅可以托管代码，它还支持敏捷项目管理。无论是从非常简单的问题跟踪到看板和 Scrum 风格的敏捷交付。在 GitLab 上，您可以像使用专门的项目管理应用程序一样有效地管理问题、可视化整个项目的工作状态并跟踪工作量和解决优先级。相比于其他过于复杂而无法有效使用的应用程序更适合开发人员。&lt;/p&gt;
&lt;h4 id=&#34;实现&#34;&gt;实现&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;每组通过独立项目统一管理issue，在&lt;strong&gt;Readme&lt;/strong&gt;中描述使用方式及定义&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;milestone&lt;/strong&gt;管理项目版本，对齐目标。节奏很重要&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;label&lt;/strong&gt;管理优先级(&lt;code&gt;P0&lt;/code&gt;|&lt;code&gt;P1&lt;/code&gt;|&lt;code&gt;P2&lt;/code&gt;)、类型(&lt;code&gt;bug&lt;/code&gt;|&lt;code&gt;feature&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;board&lt;/strong&gt;查看&lt;strong&gt;issue&lt;/strong&gt;进度状态，配合&lt;code&gt;To Do&lt;/code&gt;、&lt;code&gt;Doing&lt;/code&gt;、&lt;code&gt;Verify&lt;/code&gt;等&lt;strong&gt;label&lt;/strong&gt;，定义&lt;strong&gt;issue生命周期&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过模板定义&lt;strong&gt;author&lt;/strong&gt;需要提供的信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;milestone&#34;&gt;Milestone&lt;/h2&gt;
&lt;p&gt;通过 &lt;strong&gt;milestone&lt;/strong&gt; 管理项目版本，对齐目标。&lt;/p&gt;
&lt;h4 id=&#34;短期里程碑&#34;&gt;短期里程碑&lt;/h4&gt;
&lt;p&gt;短期内需要达到的一个目标。&lt;/p&gt;
&lt;h4 id=&#34;季度里程碑&#34;&gt;季度里程碑&lt;/h4&gt;
&lt;p&gt;每个季度发布软件的多个版本。&lt;/p&gt;
&lt;h4 id=&#34;发布版本里程碑&#34;&gt;发布版本里程碑&lt;/h4&gt;
&lt;p&gt;一个可发布的版本，项目所有需求都已开发完成并测试通过，可交付给客户。&lt;/p&gt;
&lt;h2 id=&#34;issue&#34;&gt;Issue&lt;/h2&gt;
&lt;p&gt;为问题添加一些标签以快速识别涉及应用程序的哪个组件以及它是什么类型的问题（错误、功能请求等）非常重要。GitLab issue boards具有强大的过滤功能，通过过滤 Label 确定优先级并使团队与业务需求保持一致。&lt;/p&gt;
&lt;h4 id=&#34;标签示例&#34;&gt;标签示例&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;Label&lt;/th&gt;
&lt;th&gt;简化版Label&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;类型（type）&lt;/td&gt;
&lt;td&gt;🟥type: bug&lt;/td&gt;
&lt;td&gt;🟥bug&lt;/td&gt;
&lt;td&gt;一个bug&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟦type: feature&lt;/td&gt;
&lt;td&gt;🟦feature&lt;/td&gt;
&lt;td&gt;新增功能的需求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟩type: enhancement&lt;/td&gt;
&lt;td&gt;🟩enhancement&lt;/td&gt;
&lt;td&gt;增强&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟪type: discussion&lt;/td&gt;
&lt;td&gt;🟪discussion&lt;/td&gt;
&lt;td&gt;问题讨论会议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟨type: docs&lt;/td&gt;
&lt;td&gt;🟨documentation&lt;/td&gt;
&lt;td&gt;文档相关的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟥type: security&lt;/td&gt;
&lt;td&gt;🟥security&lt;/td&gt;
&lt;td&gt;安全性相关的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟨type: test&lt;/td&gt;
&lt;td&gt;🟨test&lt;/td&gt;
&lt;td&gt;测试相关的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;优先级（priority）&lt;/td&gt;
&lt;td&gt;🟥priority: critical&lt;/td&gt;
&lt;td&gt;🟥P0&lt;/td&gt;
&lt;td&gt;放下正在做的任何事情并处理它&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟧priority: high&lt;/td&gt;
&lt;td&gt;🟧P1&lt;/td&gt;
&lt;td&gt;需要尽快处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟨priority: medium&lt;/td&gt;
&lt;td&gt;🟨P2&lt;/td&gt;
&lt;td&gt;按计划进行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;⬜priority: low&lt;/td&gt;
&lt;td&gt;⬜P3&lt;/td&gt;
&lt;td&gt;当无事可做时处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;状态(state)&lt;/td&gt;
&lt;td&gt;🟩state: approved&lt;/td&gt;
&lt;td&gt;🟩approved&lt;/td&gt;
&lt;td&gt;问题已接收但未处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟥state: blocked&lt;/td&gt;
&lt;td&gt;🟥blocked&lt;/td&gt;
&lt;td&gt;问题由于其他事情阻塞无法进行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟨state: in progress&lt;/td&gt;
&lt;td&gt;🟨in progress&lt;/td&gt;
&lt;td&gt;正在处理中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟦state: completed&lt;/td&gt;
&lt;td&gt;🟦completed&lt;/td&gt;
&lt;td&gt;已完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;⬜state: inactive&lt;/td&gt;
&lt;td&gt;⬜inactive&lt;/td&gt;
&lt;td&gt;问题已结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;组件（component ）&lt;/td&gt;
&lt;td&gt;🟩component: frontend&lt;/td&gt;
&lt;td&gt;🟩frontend&lt;/td&gt;
&lt;td&gt;前端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟦component: backend&lt;/td&gt;
&lt;td&gt;🟦backend&lt;/td&gt;
&lt;td&gt;后端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目（project）&lt;/td&gt;
&lt;td&gt;🟧计划&lt;/td&gt;
&lt;td&gt;🟧计划&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;🟩开发中&lt;/td&gt;
&lt;td&gt;🟩开发中&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;⬜已完成&lt;/td&gt;
&lt;td&gt;⬜已完成&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;issue-template&#34;&gt;Issue template&lt;/h2&gt;
&lt;h5 id=&#34;bugmd&#34;&gt;Bug.md&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;## 概述

## Bug行为

## 期望行为

## 重现步骤

## 附件
&amp;lt;!-- URL/相关信息-id 号/截图 --&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;featuremd&#34;&gt;Feature.md&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;## 背景
&amp;lt;!-- 为何要做，不做会有怎样的问题，做了会有怎样的收益 --&amp;gt;

## 需求说明

## 方案
&amp;lt;!-- 思路或模型 --&amp;gt;

## 验证
&amp;lt;!-- 如何验证，预期的标准是什么 --&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;提交约定&#34;&gt;提交约定&lt;/h2&gt;
&lt;p&gt;建议应用此提交消息格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;可以在哪里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;feat&lt;/strong&gt; （新特性）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fix&lt;/strong&gt; （bug修复）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docs&lt;/strong&gt; （文档改动）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;style&lt;/strong&gt; （格式化, 缺失分号等; 不包括生产代码变动）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;refactor&lt;/strong&gt; （重构代码）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;test&lt;/strong&gt; （添加缺失的测试, 重构测试, 不包括生产代码变动）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;chore&lt;/strong&gt; （更新grunt任务等; 不包括生产代码变动）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;scope&lt;/strong&gt; 可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;api&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;front&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;internal&lt;/strong&gt; 等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并且&lt;strong&gt;subject&lt;/strong&gt;必须使用命令式，现在时。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;feat(api): add users profile endpoint
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整提交消息示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;

&amp;lt;body&amp;gt;

&amp;lt;footer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;fix(middleware): ensure Range headers adhere more closely to RFC 2616

Add one new dependency, use `range-parser` (Express dependency) to compute
range. It is more well-tested in the wild.

Fixes #2310
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
