<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Academic</title>
    <link>/posts/</link>
      <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 25 Sep 2020 11:08:58 +0800</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Posts</title>
      <link>/posts/</link>
    </image>
    
    <item>
      <title>MinIO安装</title>
      <link>/posts/minio%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 25 Sep 2020 11:08:58 +0800</pubDate>
      <guid>/posts/minio%E5%AE%89%E8%A3%85/</guid>
      <description>&lt;p&gt;MinIO&lt;/p&gt;
&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;wget https://dl.min.io/server/minio/release/linux-amd64/minio -O /usr/local/bin/minio
chmod +x /usr/local/bin/minio
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;环境变量&#34;&gt;环境变量&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;export MINIO_ACCESS_KEY=&amp;lt;ACCESS_KEY&amp;gt;
export MINIO_SECRET_KEY=&amp;lt;SECRET_KEY&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;单节点&#34;&gt;单节点&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;minio server /data
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;分布式&#34;&gt;分布式&lt;/h4&gt;
&lt;h5 id=&#34;单节点多磁盘&#34;&gt;单节点多磁盘&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;minio server /data{1...4}
or
minio server /data1 /data2 /data3 /data4
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;多节点多磁盘&#34;&gt;多节点多磁盘&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;minio server http://host{1...n}/export{1...m}
or
minio server http://host1/export1 http://host1/export2 http://host2/export1 http://host2/export2 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有运行分布式 MinIO 的节点需要具有相同的访问密钥和秘密密钥才能连接。为了实现这一点，建议在执行 MINIO 服务器命令之前，将所有节点上的访问密钥和秘密密钥作为环境变量 MINIO _ access _ key 和 MINIO _ secret _ key 导出。&lt;/li&gt;
&lt;li&gt;分布式 Minio 使用的磁盘里必须是干净的，里面没有数据。&lt;/li&gt;
&lt;li&gt;MinIO 创建每组4到16个驱动器的擦除编码集。您提供的驱动器总数必须是这些数字之一的倍数。&lt;/li&gt;
&lt;li&gt;_ MinIO 选择最大的 EC 设置大小，将其划分为驱动器的总数或给定的节点的总数——确保保持均匀分布，即每个节点参与每个设置的驱动器数相等。&lt;/li&gt;
&lt;li&gt;建议所有运行分布式 MinIO 设置的节点都是同构的，即相同的操作系统、相同数量的磁盘和相同的网络互连。&lt;/li&gt;
&lt;li&gt;运行分布式 MinIO 实例的服务器时间差不应超过15分钟。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;服务&#34;&gt;服务&lt;/h4&gt;
&lt;h5 id=&#34;单节点-1&#34;&gt;单节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useradd minio
passwd minio
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建默认配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOT &amp;gt;&amp;gt; /etc/default/minio
# Volume to be used for MinIO server.
MINIO_VOLUMES=&amp;quot;/tmp/minio/&amp;quot;
# Use if you want to run MinIO on a custom port.
MINIO_OPTS=&amp;quot;--address :9199&amp;quot;
# Access Key of the server.
MINIO_ACCESS_KEY=Server-Access-Key
# Secret key of the server.
MINIO_SECRET_KEY=Server-Secret-Key
   
EOT
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载 service 文件 &lt;a href=&#34;https://raw.githubusercontent.com/minio/minio-service/master/linux-systemd/minio.service&#34;&gt;https://raw.githubusercontent.com/minio/minio-service/master/linux-systemd/minio.service&lt;/a&gt; 到 /etc/systemd/system/，&lt;strong&gt;并替换里面的用户和组&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=MinIO
Documentation=https://docs.min.io
Wants=network-online.target
After=network-online.target
AssertFileIsExecutable=/usr/local/bin/minio
   
[Service]
WorkingDirectory=/usr/local/
   
User=minio-user
Group=minio-user
   
EnvironmentFile=/etc/default/minio
ExecStartPre=/bin/bash -c &amp;quot;if [ -z \&amp;quot;${MINIO_VOLUMES}\&amp;quot; ]; then echo \&amp;quot;Variable MINIO_VOLUMES not set in /etc/default/minio\&amp;quot;; exit 1; fi&amp;quot;
   
ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES
   
# Let systemd restart this service always
Restart=always
   
# Specifies the maximum file descriptor number that can be opened by this process
LimitNOFILE=65536
   
# Disable timeout logic and wait until process is stopped
TimeoutStopSec=infinity
SendSIGKILL=no
   
[Install]
WantedBy=multi-user.target
   
# Built for ${project.name}-${project.version} (${project.name})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl daemon-reload
systemctl start minio
systemctl enable minio
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;分布式-1&#34;&gt;分布式&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useradd minio
passwd minio
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建存储目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir /export
sudo chown -R minio /export &amp;amp;&amp;amp; sudo chmod u+rxw /export
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建默认配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOT &amp;gt;&amp;gt; /etc/default/minio
# Remote volumes to be used for MinIO server.
MINIO_VOLUMES=http://node{1...6}/export{1...32}
# Use if you want to run MinIO on a custom port.
MINIO_OPTS=&amp;quot;--address :9199&amp;quot;
# Access Key of the server.
MINIO_ACCESS_KEY=Server-Access-Key
# Secret key of the server.
MINIO_SECRET_KEY=Server-Secret-Key
   
EOT
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载 service 文件 &lt;a href=&#34;https://raw.githubusercontent.com/minio/minio-service/master/linux-systemd/distributed/minio.service&#34;&gt;https://raw.githubusercontent.com/minio/minio-service/master/linux-systemd/distributed/minio.service&lt;/a&gt; 到 /etc/systemd/system/，&lt;strong&gt;并替换里面的用户和组&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=MinIO
Documentation=https://docs.min.io
Wants=network-online.target
After=network-online.target
AssertFileIsExecutable=/usr/local/bin/minio
   
[Service]
WorkingDirectory=/usr/local
   
User=minio-user
Group=minio-user
   
EnvironmentFile=-/etc/default/minio
ExecStartPre=/bin/bash -c &amp;quot;if [ -z \&amp;quot;${MINIO_VOLUMES}\&amp;quot; ]; then echo \&amp;quot;Variable MINIO_VOLUMES not set in /etc/default/minio\&amp;quot;; exit 1; fi&amp;quot;
ExecStartPre=/bin/bash -c &amp;quot;if [ -z \&amp;quot;${MINIO_ACCESS_KEY}\&amp;quot; ]; then echo \&amp;quot;Variable MINIO_ACCESS_KEY not set in /etc/default/minio\&amp;quot;; exit 1; fi&amp;quot;
ExecStartPre=/bin/bash -c &amp;quot;if [ -z \&amp;quot;${MINIO_SECRET_KEY}\&amp;quot; ]; then echo \&amp;quot;Variable MINIO_SECRET_KEY not set in /etc/default/minio\&amp;quot;; exit 1; fi&amp;quot;
   
ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES
   
# Let systemd restart this service always
Restart=always
   
# Specifies the maximum file descriptor number that can be opened by this process
LimitNOFILE=65536
   
# Disable timeout logic and wait until process is stopped
TimeoutStopSec=infinity
SendSIGKILL=no
   
[Install]
WantedBy=multi-user.target
   
# Built for ${project.name}-${project.version} (${project.name})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl daemon-reload
systemctl start minio
systemctl enable minio
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;客户端&#34;&gt;客户端&lt;/h4&gt;
&lt;h5 id=&#34;安装-1&#34;&gt;安装&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;wget https://dl.min.io/client/mc/release/linux-amd64/mc -O /usr/local/bin/mc
chmod +x /usr/local/bin/mc
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;常用命令&#34;&gt;常用命令&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ls&lt;/td&gt;
&lt;td&gt;list buckets and objects&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;挂载minio为本地路径&#34;&gt;挂载minio为本地路径&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装goofys&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install -y fuse
wget https://github.com/kahing/goofys/releases/latest/download/goofys -P /usr/local/bin/
chmod +x /usr/local/bin/goofys
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置认证信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir ~/.aws
$ cat &amp;lt;&amp;lt;EOT &amp;gt; ~/.aws/credentials
[default]
aws_access_key_id=Server-Access-Key
aws_secret_access_key=Server-Secret-Key
EOT
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;goofys &amp;lt;bucket&amp;gt; &amp;lt;mountpoint&amp;gt;
goofys &amp;lt;bucket:prefix&amp;gt; &amp;lt;mountpoint&amp;gt; # if you only want to mount objects under a prefix
   
# 示例
goofys --endpoint http://10.111.54.230:9000 test /minio-local-data
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开机自动挂载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改 /etc/fstab, 添加如下内容
goofys#bucket /mnt/mountpoint fuse _netdev,allow_other,--file-mode=0666,--dir-mode=0777 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;卸载&#34;&gt;卸载&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;fusermount -u /path/to/mountpoint
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>/posts/linux/</link>
      <pubDate>Wed, 23 Sep 2020 16:08:58 +0800</pubDate>
      <guid>/posts/linux/</guid>
      <description>&lt;p&gt;Linux - CentOS&lt;/p&gt;
&lt;h4 id=&#34;查看系统版本&#34;&gt;查看系统版本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/redhat-release
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;hostname&#34;&gt;hostname&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置 hostname&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo hostnamectl set-hostname newname
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 /etc/hosts&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;gt;&amp;gt; /etc/hosts &amp;lt;&amp;lt; EOF
192.168.1.100    domain1
192.168.1.101    domain2
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启networking&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl restart network
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;跟踪脚本&#34;&gt;跟踪脚本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;bash -x *.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;挂载光盘为本地源&#34;&gt;挂载光盘为本地源&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;挂载光盘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mount /dev/cdrom /mnt/cdrom
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置本地源文件CentOS-Media.repo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;baseurl修改第二个路径为上步的挂载点(/mnt/cdrom)
enabled=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁用默认的yum网络源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将yum 网络源配置文件改名为CentOS-Base.repo.bak,否则会先在网络源中寻找适合的包,改名之后直接从本地源读取.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;硬盘挂载及扩容&#34;&gt;硬盘挂载及扩容&lt;/h4&gt;
&lt;h5 id=&#34;新硬盘挂载&#34;&gt;新硬盘挂载&lt;/h5&gt;
&lt;p&gt;&lt;em&gt;参考：http://www.linuxidc.com/Linux/2012-07/65294.htm&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看硬盘分区情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo fdisk -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新硬盘分区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo fdisk /dev/sda
Command (m for help)
n：增加新分区
e：扩展分区
Partition number(1-4)：默认1,只分一个区
cylinder：默认
分区大小：默认
p：显示分区表
w：保存分区表
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看分区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;格式化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mkfs -t ext4 /dev/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂载目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mount -t ext4 /dev/sda /mnt/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开机自动挂载(编辑/etc/fstab)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在最后一行加入
/dev/sda1 /mnt/sda1 ext4 defaults 1 2
或者
UUID=37eaa526-5d96-4237-8468-603df5216ce9 /mnt/sda ext4 defaults 0 3
**UUID可以通过使用blkid命令来查看(sudo blkid /dev/sda)
**０表示不备份；１表示要将整个&amp;lt;file system&amp;gt;中的内容备份。此处建议设置为０。
**０表示不检查；挂载点为分区／（根分区）必须设置为１，其他的挂载点不能设置为１
分区      挂载目录 文件格式
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;新硬盘扩容根节点&#34;&gt;新硬盘扩容根节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看硬盘分区情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo fdisk -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建物理卷&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pvcreate /dev/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看创建好的物理卷&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pvdisplay /dev/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卷组扩容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vgextend gafis70-vg /dev/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看扩容之后的卷组信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vgdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑卷扩容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 指定大小
lvextend -l +8G /dev/gafis-vg/root
# 全部
lvextend -l +100%free /dev/gafis-vg/root
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看扩容之后的逻辑卷&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lvdisplay /dev/gafis-vg/root
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件系统扩容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;resize2fs /dev/mapper/gafis--vg-root
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;ssh&#34;&gt;ssh&lt;/h4&gt;
&lt;h5 id=&#34;免密&#34;&gt;免密&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生成密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将公钥追加到认证文件中(本机免密)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat ~/.ssh/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将公钥追加到其他机器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-copy-id root@remote_ip
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;免密2&#34;&gt;免密2&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生成密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;pass&amp;quot;
文件名: 回车
密码: pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将公钥追加到其他机器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-copy-id root@remote_ip
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ssh-agent&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-agent bash
ssh-add .ssh/id_rsa
输入密码
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;防火墙&#34;&gt;防火墙&lt;/h4&gt;
&lt;p&gt;&amp;ndash; firewalld默认开放ssh服务, 默认规则都添加到zone=public
参数
&amp;ndash;zone #作用域
&amp;ndash;add-port=80/tcp #添加端口，格式为：端口/通讯协议
&amp;ndash;permanent #永久生效，没有此参数重启后失效&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开放http(80)服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --add-service=http
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久开放http服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --add-service=http --permanent
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --remove-service=http --permanent
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启防火墙生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 所有
firewall-cmd --list-all
# 端口
firewall-cmd --list-ports
# 服务
firewall-cmd --list-services
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询服务启用状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --query-service http
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久开放端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --add-port=3128/tcp --permanent
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ulimit最大进程数和最大文件打开数&#34;&gt;ulimit（最大进程数和最大文件打开数)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 最大文件打开数
ulimit -n
# 最大进程数
ulimit -u
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时修改（重启后失效）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ulimit -n 204800
ulimit -u 204800
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久修改，修改 /etc/security/limits.conf 文件，在文件末尾添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* soft nofile 204800
* hard nofile 204800
* soft nproc 204800
* hard nproc 204800
    
*          代表针对所有用户 
noproc     是代表最大进程数 
nofile     是代表最大文件打开数
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;vmmax_map_count&#34;&gt;vm.max_map_count&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl -a | grep vm.max_map_count
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时修改（重启后失效）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl -w vm.max_map_count=262144
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久修改，修改 /etc/sysctl.conf 文件，在文件末尾添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vm.max_map_count=262144
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl -p
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;后台守护进程&#34;&gt;后台守护进程&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;setsid myscript.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;lt; /dev/null &amp;amp;
# 输出到日志文件
setsid myscript.sh &amp;gt;/path/to/logfile 2&amp;gt;&amp;amp;1 &amp;lt; /dev/null &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;swap&#34;&gt;swap&lt;/h4&gt;
&lt;h5 id=&#34;添加swap分区&#34;&gt;添加swap分区&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# 添加8G的swap分区
dd if=/dev/zero of=/home/swap bs=1024 count=8388608
mkswap /home/swap
swapon /home/swap
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;禁用swap&#34;&gt;禁用swap&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;sudo swapoff -a
sudo sed -i &#39;/ swap / s/^\(.*\)$/#\1/g&#39; /etc/fstab
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;禁用selinux&#34;&gt;禁用SELinux&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sestatus
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo setenforce 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed -i &#39;s/enforcing/disabled/g&#39; /etc/selinux/config /etc/selinux/config
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;监控文件夹&#34;&gt;监控文件夹&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;watch -n 0.1 ls &amp;lt;your_folder&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Redis安装</title>
      <link>/posts/redis%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 01 Sep 2020 17:11:11 +0800</pubDate>
      <guid>/posts/redis%E5%AE%89%E8%A3%85/</guid>
      <description>&lt;h4 id=&#34;redis-cluster&#34;&gt;Redis Cluster&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注：建议6个节点。在没有6个节点的情况下，每个节点可以创建2个实例&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载安装包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget http://download.redis.io/releases/redis-5.0.5.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar zxf redis-5.0.5.tar.gz -C /opt/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum -y install gcc-c++
cd /opt/redis-5.0.5/ &amp;amp;&amp;amp; make MALLOC=libc
./utils/install_server.sh
# 1 Please select the redis port for this instance: [6379] -- 
# 2 Please select the redis config file name [/etc/redis/6379.conf] --
# 3 Please select the redis log file name [/var/log/redis_6379.log] --
# 4 Please select the data directory for this instance [/var/lib/redis/6379] --
# 5 Please select the redis executable path [] -- /opt/redis-5.0.5/src/redis-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置 /etc/redis/6379.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 绑定地址
bind 0.0.0.0
# 端口
port 6379
# 安全密码
requirepass foobared
## =========集群相关=========
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000
appendonly yes
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl restart redis_6379
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建集群&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 3个主节点, 3个副本节点
redis-cli --cluster create 192.168.201.101:6379 192.168.201.101:6380 192.168.201.102:6379 192.168.201.102:6380 192.168.201.103:6379 192.168.201.103:6380 -a foobared --cluster-replicas 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建别名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改 ~/.bashrc，添加如下内容
alias redis-cli=/opt/redis-5.0.5/src/redis-cli
alias redis-server=/opt/redis-5.0.5/src/redis-server
# 生效
source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Goofys挂载minio为本地路径</title>
      <link>/posts/minio/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Fri, 12 Jun 2020 14:38:16 +0800</pubDate>
      <guid>/posts/minio/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</guid>
      <description>&lt;p&gt;goofys 挂载 minio 为本地路径&lt;/p&gt;
&lt;h4 id=&#34;goofys&#34;&gt;goofys&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/kahing/goofys/releases/latest/download/goofys -P /usr/local/bin/
chmod +x /usr/local/bin/goofys
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置认证信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat ~/.aws/credentials
[default]
aws_access_key_id = AKID1234567890
aws_secret_access_key = MY-SECRET-KEY
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;挂载minio&#34;&gt;挂载minio&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;挂载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;goofys &amp;lt;bucket&amp;gt; &amp;lt;mountpoint&amp;gt;
goofys &amp;lt;bucket:prefix&amp;gt; &amp;lt;mountpoint&amp;gt; # if you only want to mount objects under a prefix
   
# 示例
goofys --endpoint http://10.111.54.230:9000 test /minio-local-data
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开机自动挂载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改 /etc/fstab, 添加如下内容
goofys#bucket /mnt/mountpoint fuse _netdev,allow_other,--file-mode=0666,--dir-mode=0777 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装minio</title>
      <link>/posts/minio/kubernetes%E5%AE%89%E8%A3%85minio/</link>
      <pubDate>Fri, 12 Jun 2020 13:48:12 +0800</pubDate>
      <guid>/posts/minio/kubernetes%E5%AE%89%E8%A3%85minio/</guid>
      <description>&lt;p&gt;通过 helm 在 kubernetes 上安装 minio&lt;/p&gt;
&lt;h4 id=&#34;前提&#34;&gt;前提&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;3台服务器，CentOS7 系统&lt;/li&gt;
&lt;li&gt;已安装Kubernetes环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;安装helm3&#34;&gt;安装helm3&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载安装包 &lt;a href=&#34;https://github.com/helm/helm/releases&#34;&gt;https://github.com/helm/helm/releases&lt;/a&gt;，选择 Linux amd64 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf helm-v3.0.0-linux-amd64.tar.gz
mv linux-amd64/helm /usr/local/bin/helm
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加仓库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm repo add stable https://kubernetes-charts.storage.googleapis.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;安装kubeapps&#34;&gt;安装kubeapps&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm repo add bitnami https://charts.bitnami.com/bitnami
kubectl create namespace kubeapps
helm install kubeapps --namespace kubeapps bitnami/kubeapps --set useHelm3=true
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 Kubernetes API token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create serviceaccount kubeapps-operator
kubectl create clusterrolebinding kubeapps-operator --clusterrole=cluster-admin --serviceaccount=default:kubeapps-operator
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret $(kubectl get serviceaccount kubeapps-operator -o jsonpath=&#39;{range .secrets[*]}{.name}{&amp;quot;\n&amp;quot;}{end}&#39; | grep kubeapps-operator-token) -o jsonpath=&#39;{.data.token}&#39; -o go-template=&#39;{{.data.token | base64decode}}&#39; &amp;amp;&amp;amp; echo
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启 Dashboard&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl port-forward -n kubeapps --address 0.0.0.0 svc/kubeapps 8080:80
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;创建minio-pv&#34;&gt;创建minio PV&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 StorageClass&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage-minio
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 minio 需要的 PV&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里在 k8s的2个 worker 节点上创建了4个pv，因为minio分布式最少需要4个节点，所里这里在2个worker节点上分别创建了2个存储目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-minio-0
spec:
  capacity:
    storage: 2Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-minio
  local:
    path: /localdata/minio/data-0
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node2
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-minio-1
spec:
  capacity:
    storage: 2Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-minio
  local:
    path: /localdata/minio/data-1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node2
---
   
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-minio-2
spec:
  capacity:
    storage: 2Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-minio
  local:
    path: /localdata/minio/data-2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-minio-3
spec:
  capacity:
    storage: 2Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-minio
  local:
    path: /localdata/minio/data-3
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动创建PV目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# node2
mkdir -p /localdata/minio/data-0
mkdir -p /localdata/minio/data-1
   
# node3
mkdir -p /localdata/minio/data-2
mkdir -p /localdata/minio/data-3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;kubeapps-部署-minio&#34;&gt;kubeapps 部署 minio&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;搜索 Chart，选择 bitnami 仓库的 Chart&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-catalog-minio.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-deploy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-submit-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改Values的一些属性&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;原始值&lt;/th&gt;
&lt;th&gt;新值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mode&lt;/td&gt;
&lt;td&gt;standalone&lt;/td&gt;
&lt;td&gt;distributed&lt;/td&gt;
&lt;td&gt;集群模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resources.requests&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;requests:&lt;br/&gt;    cpu: 250m&lt;br/&gt;    memory: 256Mi&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;persistence.size&lt;/td&gt;
&lt;td&gt;8Gi&lt;/td&gt;
&lt;td&gt;1Gi&lt;/td&gt;
&lt;td&gt;该值修改为 minio PV 的一半，如果设置成一样大，有可能出现自动创建的 PVC 无法绑定的情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;persistence.storageClass&lt;/td&gt;
&lt;td&gt;&amp;ldquo;-&amp;rdquo;&lt;/td&gt;
&lt;td&gt;local-storage-minio&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;networkPolicy.enabled&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;networkPolicy.allowExternal&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;具体参数请参考官方文档：https://github.com/bitnami/charts/tree/master/bitnami/minio&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击下方的 Submit 按钮提交&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-submit-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待部署完成，即4个Pod都Ready的时候&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-detail.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启minio WebUI&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl port-forward --address 0.0.0.0 svc/minio 9000:9000
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;minio-webui.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;账号密码可以通过minio 详情页面查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kubeapps-minio-key-secret.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装</title>
      <link>/posts/kubernetes/kubernetes%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 09 Jun 2020 18:36:00 +0800</pubDate>
      <guid>/posts/kubernetes/kubernetes%E5%AE%89%E8%A3%85/</guid>
      <description>&lt;p&gt;kubeadm 安装 kubernets 集群&lt;/p&gt;
&lt;h4 id=&#34;准备工作&#34;&gt;准备工作&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开启防火墙端口&lt;/p&gt;
&lt;p&gt;需要开启的端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Master node(s):
   
TCP     6443*       Kubernetes API Server
TCP     2379-2380   etcd server client API
UDP     8472        flannel only
TCP     10250       Kubelet API
TCP     10251       kube-scheduler
TCP     10252       kube-controller-manager
TCP     10255       Read-Only Kubelet API
   
Worker nodes (minions):
   
UDP     8472        flannel only
TCP     10250       Kubelet API
TCP     10255       Read-Only Kubelet API
TCP     30000-32767 NodePort Services
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# 主节点
firewall-cmd --permanent --add-port=6443/tcp
firewall-cmd --permanent --add-port=2379-2380/tcp
firewall-cmd --permanent --add-port=10250/tcp
firewall-cmd --permanent --add-port=10251/tcp
firewall-cmd --permanent --add-port=10252/tcp
firewall-cmd --permanent --add-port=10255/tcp
firewall-cmd --permanent --add-port=8472/udp
firewall-cmd --add-masquerade --permanent
# only if you want NodePorts exposed on control plane IP as well
firewall-cmd --permanent --add-port=30000-32767/tcp
systemctl restart firewalld
   
# 从节点
firewall-cmd --permanent --add-port=10250/tcp
firewall-cmd --permanent --add-port=10255/tcp
firewall-cmd --permanent --add-port=8472/udp
firewall-cmd --permanent --add-port=30000-32767/tcp
firewall-cmd --add-masquerade --permanent
systemctl restart firewalld
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置hostname&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 节点1
# 设置hostname
sudo hostnamectl set-hostname node1
# 修改/etc/hosts, 添加以下信息
192.168.201.120 node1
192.168.201.121 node2
192.168.201.122 node3
   
# 节点2
# 设置hostname
sudo hostnamectl set-hostname node2
# 修改/etc/hosts, 添加以下信息
192.168.201.120 node1
192.168.201.121 node2
192.168.201.122 node3
   
# 节点3
# 设置hostname
sudo hostnamectl set-hostname node3
# 修改/etc/hosts, 添加以下信息
192.168.201.120 node1
192.168.201.121 node2
192.168.201.122 node3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 安装docker仓库
yum install -y yum-utils
yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
# 安装docker 19.03 版本
yum install -y docker-ce-19.03.11 docker-ce-cli-19.03.11 containerd.io
# 安装最新版本
#yum install -y docker-ce docker-ce-cli containerd.io
# 启动docker
systemctl enable docker &amp;amp;&amp;amp; systemctl start docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置必需的sysctl参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl net.bridge.bridge-nf-call-iptables=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁用swap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo swapoff -a
sudo sed -i &#39;/ swap / s/^\(.*\)$/#\1/g&#39; /etc/fstab
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;kubernetes-程序安装&#34;&gt;Kubernetes 程序安装&lt;/h4&gt;
&lt;h5 id=&#34;在线安装方式&#34;&gt;在线安装方式&lt;/h5&gt;
&lt;h6 id=&#34;kubeletkubeadmkubectl&#34;&gt;kubelet/kubeadm/kubectl&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
# 开启kubelet
systemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;镜像&#34;&gt;镜像&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 预先拉去镜像
kubeadm config images pull
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;离线安装方式&#34;&gt;离线安装方式&lt;/h5&gt;
&lt;h6 id=&#34;下载程序包翻墙&#34;&gt;下载程序包(翻墙)&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 下载程序
yum install -y --downloadonly kubelet kubeadm kubectl --disableexcludes=kubernetes
# 下载镜像
kubeadm config images pull
docker pull quay.io/coreos/flannel:v0.12.0-amd64
# 将镜像保存为tar文件
docker save ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;kubeletkubeadmkubectl-1&#34;&gt;kubelet/kubeadm/kubectl&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 将程序包拷贝到服务器上
# 进入rpm文件路径
yum -y install *.rpm
# 开启kubelet
systemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;镜像-1&#34;&gt;镜像&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 将kubernetes相关镜像拷贝到服务器上
# 进入镜像文件目录, 加载所有镜像
for i in `ls`; do docker load &amp;lt; $i; done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;离线文件下载地址(1.18版本)&lt;/p&gt;
&lt;h4 id=&#34;部署&#34;&gt;部署&lt;/h4&gt;
&lt;h5 id=&#34;主节点&#34;&gt;主节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# flannel
kubeadm init --pod-network-cidr=10.244.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置环境变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;root&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# /etc/profile 添加以下内容
export KUBECONFIG=/etc/kubernetes/admin.conf
# 立即生效
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常规用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置网络&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;从节点&#34;&gt;从节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加入集群&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 此命令从主节点init命令输出获得
kubeadm join 192.168.201.120:6443 --token z8clj6.i8u6s0deqsncftaz --discovery-token-ca-cert-hash sha256:a0cf54fda227bb64d6af37479ed055aad31e55df287566d3793825705355f3d8
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;检查状态ready&#34;&gt;检查状态(Ready)&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# 主节点执行
kubectl get nodes
# 输出如下
NAME    STATUS     ROLES    AGE   VERSION
node1   Ready      master   21m   v1.18.3
node2   NotReady   &amp;lt;none&amp;gt;   37s   v1.18.3
node3   NotReady   &amp;lt;none&amp;gt;   36s   v1.18.3
# 等待一会, 全部Ready
NAME    STATUS   ROLES    AGE     VERSION
node1   Ready    master   22m     v1.18.3
node2   Ready    &amp;lt;none&amp;gt;   2m25s   v1.18.3
node3   Ready    &amp;lt;none&amp;gt;   2m24s   v1.18.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;维护&#34;&gt;维护&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;删除Evicted状态Pod&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods | grep Evicted | awk &#39;{print $1}&#39; | xargs kubectl delete pod
# 指定命名空间
kubectl get pods -n ns | grep Evicted | awk &#39;{print $1}&#39; | xargs kubectl delete pod -n ns
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;问题&#34;&gt;问题&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;kubernetes 没有启动，手动启动api-server docker容器后出现错误消息：Error response from daemon: cannot join network of a non running container: 56de51eee0b8e0a327c927889e198b84f65cccd8645a092823350c7c10e530af&lt;/p&gt;
&lt;p&gt;可能原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器时间不对，重新同步下时间（data -s &amp;ldquo;&amp;quot;）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Minikube安装</title>
      <link>/posts/minikube%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 08 Jun 2020 17:52:45 +0800</pubDate>
      <guid>/posts/minikube%E5%AE%89%E8%A3%85/</guid>
      <description>&lt;p&gt;Linux 安装minikube&lt;/p&gt;
&lt;h4 id=&#34;1-安装docker&#34;&gt;1 安装docker&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ curl -fsSL https://get.docker.com/ | sh
$ sudo systemctl start docker
$ sudo systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-创建用户&#34;&gt;2 创建用户&lt;/h4&gt;
&lt;p&gt;minikube 需要非root用户运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adduser developer
passwd developer
usermod -aG sudo developer
# 如果上面命令出现 usermod: group &#39;sudo&#39; does not exist, 运行以下命令
usermod -aG wheel developer
su - developer
sudo usermod -aG docker $USER
- 重新登录
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-安装kubectl&#34;&gt;3 安装kubectl&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
$ chmod +x ./kubectl
$ sudo mv ./kubectl /usr/local/bin/kubectl
$ kubectl version --client
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-安装minikube&#34;&gt;4 安装minikube&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \
  &amp;amp;&amp;amp; chmod +x minikube
$ sudo mkdir -p /usr/local/bin/
$ sudo install minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-启动minikube&#34;&gt;5 启动minikube&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 需要翻墙
minikube start --driver=docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6-验证安装&#34;&gt;6 验证安装&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;minikube status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Goofys挂载minio为本地路径</title>
      <link>/posts/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 08 Jun 2020 14:59:38 +0800</pubDate>
      <guid>/posts/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</guid>
      <description>&lt;p&gt;goofys挂载minio为本地路径&lt;/p&gt;
&lt;h4 id=&#34;1-安装fuse&#34;&gt;1 安装fuse&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;yum -y install fuse
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-安装goofys&#34;&gt;2 安装goofys&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/kahing/goofys/releases/latest/download/goofys -O /bin/goofys &amp;amp;&amp;amp; chmod +x /bin/goofys
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-配置认证信息&#34;&gt;3 配置认证信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ cat ~/.aws/credentials
[default]
aws_access_key_id = AKID1234567890
aws_secret_access_key = MY-SECRET-KEY
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-使用&#34;&gt;4 使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ $GOPATH/bin/goofys &amp;lt;bucket&amp;gt; &amp;lt;mountpoint&amp;gt;
$ $GOPATH/bin/goofys &amp;lt;bucket:prefix&amp;gt; &amp;lt;mountpoint&amp;gt;
# 例
goofys --endpoint http://localhost:9000 bucket /mnt
# 前端运行
goofys -f --endpoint http://localhost:9000 bucket /mnt
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-开机自动挂载&#34;&gt;5 开机自动挂载&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 配置 /etc/fstab, 添加如下信息
goofys#bucket /mnt/mountpoint fuse _netdev,allow_other,--file-mode=0666,--dir-mode=0777,--endpoint=http://localhost:9000 0 0
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot整合elasticsearch和redis的问题</title>
      <link>/posts/springboot%E6%95%B4%E5%90%88elasticsearch%E5%92%8Credis%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 22 May 2020 12:38:34 +0800</pubDate>
      <guid>/posts/springboot%E6%95%B4%E5%90%88elasticsearch%E5%92%8Credis%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;问题描述：availableProcessors is already set to [8], rejecting [8]&lt;/p&gt;
&lt;p&gt;解决：https://blog.csdn.net/busishenren/article/details/90478928&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Helm安装Kfaka</title>
      <link>/posts/helm%E5%AE%89%E8%A3%85kfaka/</link>
      <pubDate>Tue, 19 May 2020 11:15:58 +0800</pubDate>
      <guid>/posts/helm%E5%AE%89%E8%A3%85kfaka/</guid>
      <description>&lt;p&gt;本文介绍如何使用 helm 安装 Kafka，使用本地存储的方式。&lt;/p&gt;
&lt;h4 id=&#34;1-配置-chart-仓库&#34;&gt;1 配置 chart 仓库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm repo add incubator http://storage.googleapis.com/kubernetes-charts-incubator
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-创建本地存储storageclass&#34;&gt;2 创建本地存储StorageClass&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f local-storage-class.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里绑定模式选择 WaitForFirstConsumer&lt;/p&gt;
&lt;p&gt;默认情况下，Immediate 模式指示在创建 PersistentVolumeClaim 之后发生卷绑定和动态配置。 对于拓扑受限且不能从集群中的所有节点全局访问的存储后端，persistentvolume 将在不知道 Pod 的调度需求的情况下进行绑定或提供。 这可能会导致不可调度的Pod。&lt;/p&gt;
&lt;p&gt;集群管理员可以通过指定 WaitForFirstConsumer 模式来解决这个问题，该模式将延迟 PersistentVolume 的绑定和配置，直到创建使用 PersistentVolumeClaim 的 Pod。 Persistentvolumes 将根据 Pod 的调度约束所指定的拓扑结构进行选择或配给。 这些因素包括但不限于资源需求、节点选择器、Pod关联性和反关联性、污染和耐受性。&lt;/p&gt;
&lt;p&gt;Local 通过预先创建的 PersistentVolume 绑定支持 WaitForFirstConsumer。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&#34;&gt;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/volumes/#local&#34;&gt;https://kubernetes.io/docs/concepts/storage/volumes/#local&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-创建kafka和zookeeper的persistentvolume&#34;&gt;3 创建Kafka和Zookeeper的PersistentVolume&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;创建Kafka的PV&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-kafka-0
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/kafka/data-0
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-kafka-1
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/kafka/data-1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-kafka-2
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/kafka/data-2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /localstorage/kafka/data-0
mkdir -p /localstorage/kafka/data-1
mkdir -p /localstorage/kafka/data-2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;创建Zookeeper的PV&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-zookeeper-0
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/zookeeper/data-0
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-zookeeper-1
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/zookeeper/data-1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-zookeeper-2
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localstorage/zookeeper/data-2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /localstorage/zookeeper/data-0
mkdir -p /localstorage/zookeeper/data-1
mkdir -p /localstorage/zookeeper/data-2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要在节点上手动创建下存储目录 ，Kubernetes不会自动创建它。&lt;/p&gt;
&lt;p&gt;使用本地卷时需要 PersistentVolume nodeAffinity。 它使 Kubernetes 调度程序能够将使用本地卷的 Pods 正确调度到正确的节点。&lt;/p&gt;
&lt;h4 id=&#34;4-部署kafka&#34;&gt;4 部署Kafka&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建value文件kafka-values.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;external:
  enabled: true
configurationOverrides:
  &amp;quot;advertised.listeners&amp;quot;: |-
    EXTERNAL://192.168.1.1:$((31090 + ${KAFKA_BROKER_ID}))
  &amp;quot;listener.security.protocol.map&amp;quot;: |-
    PLAINTEXT:PLAINTEXT,EXTERNAL:PLAINTEXT
persistence:
  storageClass: local-storage
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里开启外部访问，配置IP地址（第5行），集群任意节点均可，同时配置storageClass。其他更多配置看官方文档 &lt;a href=&#34;https://github.com/helm/charts/tree/master/incubator/kafka&#34;&gt;https://github.com/helm/charts/tree/master/incubator/kafka&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install kafka-dev -f kafka-values.yaml incubator/kafka
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-查看kafka版本&#34;&gt;5 查看Kafka版本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kubectl exec kafka-dev-0 -- ls /usr/share/java/kafka | grep kafka
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;问题&#34;&gt;问题&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;no persistent volumes available for this claim and no storage class is set&lt;/p&gt;
&lt;p&gt;可能原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;values.yaml 中的 persistence.size 属性大于 PV 中 storage 大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在PVC绑定PV时通常根据两个条件来绑定，一个是存储的大小，另一个就是访问模式。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zookeeper Cannot open channel to 1 at election&lt;/p&gt;
&lt;p&gt;可能原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动zookeeper的时候，上一次启动的数据没有删除（挂载PV目录）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Helm安装MySQL</title>
      <link>/posts/helm%E5%AE%89%E8%A3%85mysql/</link>
      <pubDate>Fri, 15 May 2020 17:37:27 +0800</pubDate>
      <guid>/posts/helm%E5%AE%89%E8%A3%85mysql/</guid>
      <description>&lt;p&gt;本文介绍如何使用 helm 安装 MySQL，使用本地存储的方式。&lt;/p&gt;
&lt;h4 id=&#34;1-创建storageclass&#34;&gt;1 创建StorageClass&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage-mysql
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里绑定模式选择 WaitForFirstConsumer&lt;/p&gt;
&lt;p&gt;默认情况下，Immediate 模式指示在创建 PersistentVolumeClaim 之后发生卷绑定和动态配置。 对于拓扑受限且不能从集群中的所有节点全局访问的存储后端，persistentvolume 将在不知道 Pod 的调度需求的情况下进行绑定或提供。 这可能会导致不可调度的Pod。&lt;/p&gt;
&lt;p&gt;集群管理员可以通过指定 WaitForFirstConsumer 模式来解决这个问题，该模式将延迟 PersistentVolume 的绑定和配置，直到创建使用 PersistentVolumeClaim 的 Pod。 Persistentvolumes 将根据 Pod 的调度约束所指定的拓扑结构进行选择或配给。 这些因素包括但不限于资源需求、节点选择器、Pod关联性和反关联性、污染和耐受性。&lt;/p&gt;
&lt;p&gt;Local 通过预先创建的 PersistentVolume 绑定支持 WaitForFirstConsumer。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&#34;&gt;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/volumes/#local&#34;&gt;https://kubernetes.io/docs/concepts/storage/volumes/#local&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-创建persistentvolume&#34;&gt;2 创建PersistentVolume&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-mysql
spec:
  capacity:
    storage: 10Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-mysql
  local:
    path: /db/mysql
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用本地卷时需要 PersistentVolume nodeAffinity。 它使 Kubernetes 调度程序能够将使用本地卷的 Pods 正确调度到正确的节点。&lt;/p&gt;
&lt;h4 id=&#34;3-在指定节点上创建存储目录&#34;&gt;3 在指定节点上创建存储目录&lt;/h4&gt;
&lt;p&gt;这里需要在节点 node3 上手动创建存储目录 /db/mysql，Kubernetes不会自动创建它。&lt;/p&gt;
&lt;h4 id=&#34;4-安装mysql&#34;&gt;4 安装MySQL&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm install my-mysql --set persistence.storageClass=local-storage-mysql stable/mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里设置 storageClassName 属性为上面创建的 StorageClass，其他可设置属性参看官方说明 &lt;a href=&#34;https://github.com/helm/charts/tree/master/stable/mysql#configuration&#34;&gt;https://github.com/helm/charts/tree/master/stable/mysql#configuration&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>/posts/docker/</link>
      <pubDate>Wed, 13 May 2020 17:56:03 +0800</pubDate>
      <guid>/posts/docker/</guid>
      <description>&lt;h3 id=&#34;安装centos&#34;&gt;安装(CentOS)&lt;/h3&gt;
&lt;p&gt;1 更新Yum&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo yum update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 添加docker仓库并安装docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -fsSL https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 启动docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl start docker
sudo systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://geekflare.com/docker-installation-guide/&#34;&gt;https://geekflare.com/docker-installation-guide/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;删除所有none镜像&#34;&gt;删除所有none镜像&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;docker rmi $(docker images | awk &#39;/^&amp;lt;none&amp;gt;/ { print $3 }&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dockerfile&#34;&gt;Dockerfile&lt;/h3&gt;
&lt;h4 id=&#34;时区&#34;&gt;时区&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;FROM alpine:3.6
RUN apk add --no-cache tzdata
ENV TZ Asia/Shanghai
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Hugo Github Pages</title>
      <link>/posts/hugo-github-pages/</link>
      <pubDate>Wed, 13 May 2020 15:45:43 +0800</pubDate>
      <guid>/posts/hugo-github-pages/</guid>
      <description>&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;p&gt;1 在github上创建仓库&amp;lt;USERNAME&amp;gt;.github.io&lt;/p&gt;
&lt;p&gt;2 
&lt;a href=&#34;https://github.com/sourcethemes/academic-kickstart#fork-destination-box&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;fork&lt;/strong&gt;&lt;/a&gt; &lt;em&gt;Academic Kickstart&lt;/em&gt; 仓库，并clone到本地（替换你的用户名）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/&amp;lt;USERNAME&amp;gt;/academic-kickstart.git My_Website
cd My_Website
git submodule update --init --recursive
git submodule add -f -b master https://github.com/&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 将所有内容添加到本地 git 存储库，并将其推送到 GitHub 上的远程存储库:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;Initial commit&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 通过运行 Hugo 重新生成网站的 HTML 代码，并将 public 子模块上传到 GitHub:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo
cd public
git add .
git commit -m &amp;quot;Build website&amp;quot;
git push origin master
cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5 通过浏览器访问 https://&lt;USERNAME&gt;.github.io&lt;/p&gt;
&lt;h3 id=&#34;添加内容&#34;&gt;添加内容&lt;/h3&gt;
&lt;p&gt;1 创建文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo new posts/my-first-post.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 部署脚本 deploy.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh

# If a command fails then the deploy stops
set -e

printf &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m\n&amp;quot;

# Build the project.
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

# Go To Public folder
cd public

# Add changes to git.
git add .

# Commit changes.
msg=&amp;quot;rebuilding site $(date)&amp;quot;
if [ -n &amp;quot;$*&amp;quot; ]; then
	msg=&amp;quot;$*&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 更新网站&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./deploy.sh &amp;quot;Your optional commit message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://georgecushen.com/create-your-website-with-hugo/&#34;&gt;https://georgecushen.com/create-your-website-with-hugo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://sourcethemes.com/academic/docs/deployment/&#34;&gt;https://sourcethemes.com/academic/docs/deployment/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
