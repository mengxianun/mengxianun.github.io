<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Academic</title>
    <link>/posts/</link>
      <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 09 Jun 2020 18:36:00 +0800</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Posts</title>
      <link>/posts/</link>
    </image>
    
    <item>
      <title>Kubernetes安装</title>
      <link>/posts/kubernetes/kubernetes%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 09 Jun 2020 18:36:00 +0800</pubDate>
      <guid>/posts/kubernetes/kubernetes%E5%AE%89%E8%A3%85/</guid>
      <description>&lt;p&gt;kubeadm 安装 kubernets 集群&lt;/p&gt;
&lt;h4 id=&#34;准备工作&#34;&gt;准备工作&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开启防火墙端口&lt;/p&gt;
&lt;p&gt;需要开启的端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Master node(s):
   
TCP     6443*       Kubernetes API Server
TCP     2379-2380   etcd server client API
UDP     8472        flannel only
TCP     10250       Kubelet API
TCP     10251       kube-scheduler
TCP     10252       kube-controller-manager
TCP     10255       Read-Only Kubelet API
   
Worker nodes (minions):
   
UDP     8472        flannel only
TCP     10250       Kubelet API
TCP     10255       Read-Only Kubelet API
TCP     30000-32767 NodePort Services
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# 主节点
firewall-cmd --permanent --add-port=6443/tcp
firewall-cmd --permanent --add-port=2379-2380/tcp
firewall-cmd --permanent --add-port=10250/tcp
firewall-cmd --permanent --add-port=10251/tcp
firewall-cmd --permanent --add-port=10252/tcp
firewall-cmd --permanent --add-port=10255/tcp
firewall-cmd --permanent --add-port=8472/udp
firewall-cmd --add-masquerade --permanent
# only if you want NodePorts exposed on control plane IP as well
firewall-cmd --permanent --add-port=30000-32767/tcp
systemctl restart firewalld
   
# 从节点
firewall-cmd --permanent --add-port=10250/tcp
firewall-cmd --permanent --add-port=10255/tcp
firewall-cmd --permanent --add-port=8472/udp
firewall-cmd --permanent --add-port=30000-32767/tcp
firewall-cmd --add-masquerade --permanent
systemctl restart firewalld
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置hostname&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 节点1
# 设置hostname
sudo hostnamectl set-hostname node1
# 修改/etc/hosts, 添加以下信息
192.168.201.120 node1
192.168.201.121 node2
192.168.201.122 node3
   
# 节点2
# 设置hostname
sudo hostnamectl set-hostname node2
# 修改/etc/hosts, 添加以下信息
192.168.201.120 node1
192.168.201.121 node2
192.168.201.122 node3
   
# 节点3
# 设置hostname
sudo hostnamectl set-hostname node3
# 修改/etc/hosts, 添加以下信息
192.168.201.120 node1
192.168.201.121 node2
192.168.201.122 node3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 安装docker仓库
yum install -y yum-utils
yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
# 安装docker 19.03 版本
yum install -y docker-ce-19.03.11 docker-ce-cli-19.03.11 containerd.io
# 安装最新版本
#yum install -y docker-ce docker-ce-cli containerd.io
# 启动docker
systemctl enable docker &amp;amp;&amp;amp; systemctl start docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置必需的sysctl参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysctl net.bridge.bridge-nf-call-iptables=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁用swap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo swapoff -a
sudo sed -i &#39;/ swap / s/^\(.*\)$/#\1/g&#39; /etc/fstab
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;kubernetes-程序安装&#34;&gt;Kubernetes 程序安装&lt;/h4&gt;
&lt;h5 id=&#34;在线安装方式&#34;&gt;在线安装方式&lt;/h5&gt;
&lt;h6 id=&#34;kubeletkubeadmkubectl&#34;&gt;kubelet/kubeadm/kubectl&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
# 开启kubelet
systemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;镜像&#34;&gt;镜像&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 预先拉去镜像
kubeadm config images pull
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;离线安装方式&#34;&gt;离线安装方式&lt;/h5&gt;
&lt;h6 id=&#34;下载程序包翻墙&#34;&gt;下载程序包(翻墙)&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 下载程序
yum install -y --downloadonly kubelet kubeadm kubectl --disableexcludes=kubernetes
# 下载镜像
kubeadm config images pull
docker pull quay.io/coreos/flannel:v0.12.0-amd64
# 将镜像保存为tar文件
docker save ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;kubeletkubeadmkubectl-1&#34;&gt;kubelet/kubeadm/kubectl&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 将程序包拷贝到服务器上
# 进入rpm文件路径
yum -y install *.rpm
# 开启kubelet
systemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;镜像-1&#34;&gt;镜像&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;# 将kubernetes相关镜像拷贝到服务器上
# 进入镜像文件目录, 加载所有镜像
for i in `ls`; do docker load &amp;lt; $i; done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;离线文件下载地址(1.18版本)&lt;/p&gt;
&lt;h4 id=&#34;部署&#34;&gt;部署&lt;/h4&gt;
&lt;h5 id=&#34;主节点&#34;&gt;主节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# flannel
kubeadm init --pod-network-cidr=10.244.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置环境变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;root&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# /etc/profile 添加以下内容
export KUBECONFIG=/etc/kubernetes/admin.conf
# 立即生效
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常规用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置网络&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;从节点&#34;&gt;从节点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加入集群&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 此命令从主节点init命令输出获得
kubeadm join 192.168.201.120:6443 --token z8clj6.i8u6s0deqsncftaz --discovery-token-ca-cert-hash sha256:a0cf54fda227bb64d6af37479ed055aad31e55df287566d3793825705355f3d8
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;检查状态ready&#34;&gt;检查状态(Ready)&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# 主节点执行
kubectl get nodes
# 输出如下
NAME    STATUS     ROLES    AGE   VERSION
node1   Ready      master   21m   v1.18.3
node2   NotReady   &amp;lt;none&amp;gt;   37s   v1.18.3
node3   NotReady   &amp;lt;none&amp;gt;   36s   v1.18.3
# 等待一会, 全部Ready
NAME    STATUS   ROLES    AGE     VERSION
node1   Ready    master   22m     v1.18.3
node2   Ready    &amp;lt;none&amp;gt;   2m25s   v1.18.3
node3   Ready    &amp;lt;none&amp;gt;   2m24s   v1.18.3
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minikube安装</title>
      <link>/posts/minikube%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 08 Jun 2020 17:52:45 +0800</pubDate>
      <guid>/posts/minikube%E5%AE%89%E8%A3%85/</guid>
      <description>&lt;p&gt;Linux 安装minikube&lt;/p&gt;
&lt;h4 id=&#34;1-安装docker&#34;&gt;1 安装docker&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ curl -fsSL https://get.docker.com/ | sh
$ sudo systemctl start docker
$ sudo systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-创建用户&#34;&gt;2 创建用户&lt;/h4&gt;
&lt;p&gt;minikube 需要非root用户运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;adduser developer
passwd developer
usermod -aG sudo developer
# 如果上面命令出现 usermod: group &#39;sudo&#39; does not exist, 运行以下命令
usermod -aG wheel developer
su - developer
sudo usermod -aG docker $USER
- 重新登录
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-安装kubectl&#34;&gt;3 安装kubectl&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
$ chmod +x ./kubectl
$ sudo mv ./kubectl /usr/local/bin/kubectl
$ kubectl version --client
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-安装minikube&#34;&gt;4 安装minikube&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \
  &amp;amp;&amp;amp; chmod +x minikube
$ sudo mkdir -p /usr/local/bin/
$ sudo install minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-启动minikube&#34;&gt;5 启动minikube&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 需要翻墙
minikube start --driver=docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6-验证安装&#34;&gt;6 验证安装&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;minikube status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Goofys挂载minio为本地路径</title>
      <link>/posts/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 08 Jun 2020 14:59:38 +0800</pubDate>
      <guid>/posts/goofys%E6%8C%82%E8%BD%BDminio%E4%B8%BA%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84/</guid>
      <description>&lt;p&gt;goofys挂载minio为本地路径&lt;/p&gt;
&lt;h4 id=&#34;1-安装fuse&#34;&gt;1 安装fuse&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;yum -y install fuse
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-安装goofys&#34;&gt;2 安装goofys&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/kahing/goofys/releases/latest/download/goofys -O /bin/goofys &amp;amp;&amp;amp; chmod +x /bin/goofys
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-配置认证信息&#34;&gt;3 配置认证信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ cat ~/.aws/credentials
[default]
aws_access_key_id = AKID1234567890
aws_secret_access_key = MY-SECRET-KEY
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-使用&#34;&gt;4 使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$ $GOPATH/bin/goofys &amp;lt;bucket&amp;gt; &amp;lt;mountpoint&amp;gt;
$ $GOPATH/bin/goofys &amp;lt;bucket:prefix&amp;gt; &amp;lt;mountpoint&amp;gt;
# 例
goofys --endpoint http://localhost:9000 bucket /mnt
# 前端运行
goofys -f --endpoint http://localhost:9000 bucket /mnt
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-开机自动挂载&#34;&gt;5 开机自动挂载&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 配置 /etc/fstab, 添加如下信息
goofys#bucket /mnt/mountpoint fuse _netdev,allow_other,--file-mode=0666,--dir-mode=0777,--endpoint=http://localhost:9000 0 0
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot整合elasticsearch和redis的问题</title>
      <link>/posts/springboot%E6%95%B4%E5%90%88elasticsearch%E5%92%8Credis%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 22 May 2020 12:38:34 +0800</pubDate>
      <guid>/posts/springboot%E6%95%B4%E5%90%88elasticsearch%E5%92%8Credis%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;问题描述：availableProcessors is already set to [8], rejecting [8]&lt;/p&gt;
&lt;p&gt;解决：https://blog.csdn.net/busishenren/article/details/90478928&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Helm安装Kfaka</title>
      <link>/posts/helm%E5%AE%89%E8%A3%85kfaka/</link>
      <pubDate>Tue, 19 May 2020 11:15:58 +0800</pubDate>
      <guid>/posts/helm%E5%AE%89%E8%A3%85kfaka/</guid>
      <description>&lt;p&gt;本文介绍如何使用 helm 安装 Kafka，使用本地存储的方式。&lt;/p&gt;
&lt;h4 id=&#34;1-配置-chart-仓库&#34;&gt;1 配置 chart 仓库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm repo add incubator http://storage.googleapis.com/kubernetes-charts-incubator
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-创建本地存储storageclass&#34;&gt;2 创建本地存储StorageClass&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f local-storage-class.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里绑定模式选择 WaitForFirstConsumer&lt;/p&gt;
&lt;p&gt;默认情况下，Immediate 模式指示在创建 PersistentVolumeClaim 之后发生卷绑定和动态配置。 对于拓扑受限且不能从集群中的所有节点全局访问的存储后端，persistentvolume 将在不知道 Pod 的调度需求的情况下进行绑定或提供。 这可能会导致不可调度的Pod。&lt;/p&gt;
&lt;p&gt;集群管理员可以通过指定 WaitForFirstConsumer 模式来解决这个问题，该模式将延迟 PersistentVolume 的绑定和配置，直到创建使用 PersistentVolumeClaim 的 Pod。 Persistentvolumes 将根据 Pod 的调度约束所指定的拓扑结构进行选择或配给。 这些因素包括但不限于资源需求、节点选择器、Pod关联性和反关联性、污染和耐受性。&lt;/p&gt;
&lt;p&gt;Local 通过预先创建的 PersistentVolume 绑定支持 WaitForFirstConsumer。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&#34;&gt;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/volumes/#local&#34;&gt;https://kubernetes.io/docs/concepts/storage/volumes/#local&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-创建kafka和zookeeper的persistentvolume&#34;&gt;3 创建Kafka和Zookeeper的PersistentVolume&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;创建Kafka的PV&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-kafka-0
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localdata/kafka/data-0
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-kafka-1
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localdata/kafka/data-1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-kafka-2
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localdata/kafka/data-2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /localdata/kafka/data-0
mkdir -p /localdata/kafka/data-1
mkdir -p /localdata/kafka/data-2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;创建Zookeeper的PV&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-zookeeper-0
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localdata/zookeeper/data-0
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-zookeeper-1
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localdata/zookeeper/data-1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-zookeeper-2
spec:
  capacity:
    storage: 5Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /localdata/zookeeper/data-2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /localdata/zookeeper/data-0
mkdir -p /localdata/zookeeper/data-1
mkdir -p /localdata/zookeeper/data-2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要在节点上手动创建下存储目录 ，Kubernetes不会自动创建它。&lt;/p&gt;
&lt;p&gt;使用本地卷时需要 PersistentVolume nodeAffinity。 它使 Kubernetes 调度程序能够将使用本地卷的 Pods 正确调度到正确的节点。&lt;/p&gt;
&lt;h4 id=&#34;4-部署kafka&#34;&gt;4 部署Kafka&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建value文件kafka-values.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;external:
  enabled: true
configurationOverrides:
  &amp;quot;advertised.listeners&amp;quot;: |-
    EXTERNAL://192.168.1.1:$((31090 + ${KAFKA_BROKER_ID}))
  &amp;quot;listener.security.protocol.map&amp;quot;: |-
    PLAINTEXT:PLAINTEXT,EXTERNAL:PLAINTEXT
persistence:
  storageClass: local-storage
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里开启外部访问，配置IP地址（第5行），集群任意节点均可，同时配置storageClass。其他更多配置看官方文档 &lt;a href=&#34;https://github.com/helm/charts/tree/master/incubator/kafka&#34;&gt;https://github.com/helm/charts/tree/master/incubator/kafka&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install kafka-dev -f kafka-values.yaml incubator/kafka
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-查看kafka版本&#34;&gt;5 查看Kafka版本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kubectl exec kafka-dev-0 -- ls /usr/share/java/kafka | grep kafka
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;问题&#34;&gt;问题&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;no persistent volumes available for this claim and no storage class is set&lt;/p&gt;
&lt;p&gt;可能原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;values.yaml 中的 persistence.size 属性大于 PV 中 storage 大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在PVC绑定PV时通常根据两个条件来绑定，一个是存储的大小，另一个就是访问模式。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Helm安装MySQL</title>
      <link>/posts/helm%E5%AE%89%E8%A3%85mysql/</link>
      <pubDate>Fri, 15 May 2020 17:37:27 +0800</pubDate>
      <guid>/posts/helm%E5%AE%89%E8%A3%85mysql/</guid>
      <description>&lt;p&gt;本文介绍如何使用 helm 安装 MySQL，使用本地存储的方式。&lt;/p&gt;
&lt;h4 id=&#34;1-创建storageclass&#34;&gt;1 创建StorageClass&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage-mysql
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里绑定模式选择 WaitForFirstConsumer&lt;/p&gt;
&lt;p&gt;默认情况下，Immediate 模式指示在创建 PersistentVolumeClaim 之后发生卷绑定和动态配置。 对于拓扑受限且不能从集群中的所有节点全局访问的存储后端，persistentvolume 将在不知道 Pod 的调度需求的情况下进行绑定或提供。 这可能会导致不可调度的Pod。&lt;/p&gt;
&lt;p&gt;集群管理员可以通过指定 WaitForFirstConsumer 模式来解决这个问题，该模式将延迟 PersistentVolume 的绑定和配置，直到创建使用 PersistentVolumeClaim 的 Pod。 Persistentvolumes 将根据 Pod 的调度约束所指定的拓扑结构进行选择或配给。 这些因素包括但不限于资源需求、节点选择器、Pod关联性和反关联性、污染和耐受性。&lt;/p&gt;
&lt;p&gt;Local 通过预先创建的 PersistentVolume 绑定支持 WaitForFirstConsumer。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&#34;&gt;https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/volumes/#local&#34;&gt;https://kubernetes.io/docs/concepts/storage/volumes/#local&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-创建persistentvolume&#34;&gt;2 创建PersistentVolume&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-storage-mysql
spec:
  capacity:
    storage: 10Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage-mysql
  local:
    path: /db/mysql
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用本地卷时需要 PersistentVolume nodeAffinity。 它使 Kubernetes 调度程序能够将使用本地卷的 Pods 正确调度到正确的节点。&lt;/p&gt;
&lt;h4 id=&#34;3-在指定节点上创建存储目录&#34;&gt;3 在指定节点上创建存储目录&lt;/h4&gt;
&lt;p&gt;这里需要在节点 node3 上手动创建存储目录 /db/mysql，Kubernetes不会自动创建它。&lt;/p&gt;
&lt;h4 id=&#34;4-安装mysql&#34;&gt;4 安装MySQL&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm install my-mysql --set persistence.storageClass=local-storage-mysql stable/mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里设置 storageClassName 属性为上面创建的 StorageClass，其他可设置属性参看官方说明 &lt;a href=&#34;https://github.com/helm/charts/tree/master/stable/mysql#configuration&#34;&gt;https://github.com/helm/charts/tree/master/stable/mysql#configuration&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>/posts/docker/</link>
      <pubDate>Wed, 13 May 2020 17:56:03 +0800</pubDate>
      <guid>/posts/docker/</guid>
      <description>&lt;h3 id=&#34;安装centos&#34;&gt;安装(CentOS)&lt;/h3&gt;
&lt;p&gt;1 更新Yum&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo yum update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 添加docker仓库并安装docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -fsSL https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 启动docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl start docker
sudo systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://geekflare.com/docker-installation-guide/&#34;&gt;https://geekflare.com/docker-installation-guide/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo Github Pages</title>
      <link>/posts/hugo-github-pages/</link>
      <pubDate>Wed, 13 May 2020 15:45:43 +0800</pubDate>
      <guid>/posts/hugo-github-pages/</guid>
      <description>&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;p&gt;1 在github上创建仓库&amp;lt;USERNAME&amp;gt;.github.io&lt;/p&gt;
&lt;p&gt;2 
&lt;a href=&#34;https://github.com/sourcethemes/academic-kickstart#fork-destination-box&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;fork&lt;/strong&gt;&lt;/a&gt; &lt;em&gt;Academic Kickstart&lt;/em&gt; 仓库，并clone到本地（替换你的用户名）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/&amp;lt;USERNAME&amp;gt;/academic-kickstart.git My_Website
cd My_Website
git submodule update --init --recursive
git submodule add -f -b master https://github.com/&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 将所有内容添加到本地 git 存储库，并将其推送到 GitHub 上的远程存储库:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;Initial commit&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 通过运行 Hugo 重新生成网站的 HTML 代码，并将 public 子模块上传到 GitHub:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo
cd public
git add .
git commit -m &amp;quot;Build website&amp;quot;
git push origin master
cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5 通过浏览器访问 https://&lt;USERNAME&gt;.github.io&lt;/p&gt;
&lt;h3 id=&#34;添加内容&#34;&gt;添加内容&lt;/h3&gt;
&lt;p&gt;1 创建文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo new posts/my-first-post.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 部署脚本 deploy.sh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh

# If a command fails then the deploy stops
set -e

printf &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m\n&amp;quot;

# Build the project.
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

# Go To Public folder
cd public

# Add changes to git.
git add .

# Commit changes.
msg=&amp;quot;rebuilding site $(date)&amp;quot;
if [ -n &amp;quot;$*&amp;quot; ]; then
	msg=&amp;quot;$*&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 更新网站&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./deploy.sh &amp;quot;Your optional commit message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://georgecushen.com/create-your-website-with-hugo/&#34;&gt;https://georgecushen.com/create-your-website-with-hugo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://sourcethemes.com/academic/docs/deployment/&#34;&gt;https://sourcethemes.com/academic/docs/deployment/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
