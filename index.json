[{"authors":["admin"],"categories":null,"content":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/author/nelson-bighetti/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/nelson-bighetti/","section":"authors","summary":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.","tags":null,"title":"Nelson Bighetti","type":"authors"},{"authors":[],"categories":[],"content":"问题描述：availableProcessors is already set to [8], rejecting [8]\n解决：https://blog.csdn.net/busishenren/article/details/90478928\n","date":1590122314,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590122314,"objectID":"3eb0ee451334c7372d1ae573e19e3f70","permalink":"/posts/springboot%E6%95%B4%E5%90%88elasticsearch%E5%92%8Credis%E7%9A%84%E9%97%AE%E9%A2%98/","publishdate":"2020-05-22T12:38:34+08:00","relpermalink":"/posts/springboot%E6%95%B4%E5%90%88elasticsearch%E5%92%8Credis%E7%9A%84%E9%97%AE%E9%A2%98/","section":"posts","summary":"问题描述：availableProcessors is already set to [8], rejecting","tags":[],"title":"SpringBoot整合elasticsearch和redis的问题","type":"posts"},{"authors":[],"categories":[],"content":"本文介绍如何使用 helm 安装 Kafka，使用本地存储的方式。\n1 配置 chart 仓库 helm repo add incubator http://storage.googleapis.com/kubernetes-charts-incubator\r 2 创建本地存储StorageClass apiVersion: storage.k8s.io/v1\rkind: StorageClass\rmetadata:\rname: local-storage\rprovisioner: kubernetes.io/no-provisioner\rvolumeBindingMode: WaitForFirstConsumer\r kubectl apply -f local-storage-class.yaml\r 这里绑定模式选择 WaitForFirstConsumer\n默认情况下，Immediate 模式指示在创建 PersistentVolumeClaim 之后发生卷绑定和动态配置。 对于拓扑受限且不能从集群中的所有节点全局访问的存储后端，persistentvolume 将在不知道 Pod 的调度需求的情况下进行绑定或提供。 这可能会导致不可调度的Pod。\n集群管理员可以通过指定 WaitForFirstConsumer 模式来解决这个问题，该模式将延迟 PersistentVolume 的绑定和配置，直到创建使用 PersistentVolumeClaim 的 Pod。 Persistentvolumes 将根据 Pod 的调度约束所指定的拓扑结构进行选择或配给。 这些因素包括但不限于资源需求、节点选择器、Pod关联性和反关联性、污染和耐受性。\nLocal 通过预先创建的 PersistentVolume 绑定支持 WaitForFirstConsumer。\n参考：\nhttps://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode\nhttps://kubernetes.io/docs/concepts/storage/volumes/#local\n3 创建Kafka和Zookeeper的PersistentVolume  创建Kafka的PV  apiVersion: v1\rkind: PersistentVolume\rmetadata:\rname: local-storage-kafka-0\rspec:\rcapacity:\rstorage: 5Gi\raccessModes:\r- ReadWriteOnce\rpersistentVolumeReclaimPolicy: Retain\rstorageClassName: local-storage\rlocal:\rpath: /localdata/kafka/data-0\rnodeAffinity:\rrequired:\rnodeSelectorTerms:\r- matchExpressions:\r- key: kubernetes.io/hostname\roperator: In\rvalues:\r- node3\r---\rapiVersion: v1\rkind: PersistentVolume\rmetadata:\rname: local-storage-kafka-1\rspec:\rcapacity:\rstorage: 5Gi\raccessModes:\r- ReadWriteOnce\rpersistentVolumeReclaimPolicy: Retain\rstorageClassName: local-storage\rlocal:\rpath: /localdata/kafka/data-1\rnodeAffinity:\rrequired:\rnodeSelectorTerms:\r- matchExpressions:\r- key: kubernetes.io/hostname\roperator: In\rvalues:\r- node3\r---\rapiVersion: v1\rkind: PersistentVolume\rmetadata:\rname: local-storage-kafka-2\rspec:\rcapacity:\rstorage: 5Gi\raccessModes:\r- ReadWriteOnce\rpersistentVolumeReclaimPolicy: Retain\rstorageClassName: local-storage\rlocal:\rpath: /localdata/kafka/data-2\rnodeAffinity:\rrequired:\rnodeSelectorTerms:\r- matchExpressions:\r- key: kubernetes.io/hostname\roperator: In\rvalues:\r- node3\r mkdir -p /localdata/kafka/data-0\rmkdir -p /localdata/kafka/data-1\rmkdir -p /localdata/kafka/data-2\r  创建Zookeeper的PV  apiVersion: v1\rkind: PersistentVolume\rmetadata:\rname: local-storage-zookeeper-0\rspec:\rcapacity:\rstorage: 5Gi\raccessModes:\r- ReadWriteOnce\rpersistentVolumeReclaimPolicy: Retain\rstorageClassName: local-storage\rlocal:\rpath: /localdata/zookeeper/data-0\rnodeAffinity:\rrequired:\rnodeSelectorTerms:\r- matchExpressions:\r- key: kubernetes.io/hostname\roperator: In\rvalues:\r- node3\r---\rapiVersion: v1\rkind: PersistentVolume\rmetadata:\rname: local-storage-zookeeper-1\rspec:\rcapacity:\rstorage: 5Gi\raccessModes:\r- ReadWriteOnce\rpersistentVolumeReclaimPolicy: Retain\rstorageClassName: local-storage\rlocal:\rpath: /localdata/zookeeper/data-1\rnodeAffinity:\rrequired:\rnodeSelectorTerms:\r- matchExpressions:\r- key: kubernetes.io/hostname\roperator: In\rvalues:\r- node3\r---\rapiVersion: v1\rkind: PersistentVolume\rmetadata:\rname: local-storage-zookeeper-2\rspec:\rcapacity:\rstorage: 5Gi\raccessModes:\r- ReadWriteOnce\rpersistentVolumeReclaimPolicy: Retain\rstorageClassName: local-storage\rlocal:\rpath: /localdata/zookeeper/data-2\rnodeAffinity:\rrequired:\rnodeSelectorTerms:\r- matchExpressions:\r- key: kubernetes.io/hostname\roperator: In\rvalues:\r- node3\r mkdir -p /localdata/zookeeper/data-0\rmkdir -p /localdata/zookeeper/data-1\rmkdir -p /localdata/zookeeper/data-2\r 这里需要在节点上手动创建下存储目录 ，Kubernetes不会自动创建它。\n使用本地卷时需要 PersistentVolume nodeAffinity。 它使 Kubernetes 调度程序能够将使用本地卷的 Pods 正确调度到正确的节点。\n4 部署Kafka   创建value文件kafka-values.yaml\nexternal:\renabled: true\rconfigurationOverrides:\r\u0026quot;advertised.listeners\u0026quot;: |-\rEXTERNAL://192.168.1.1:$((31090 + ${KAFKA_BROKER_ID}))\r\u0026quot;listener.security.protocol.map\u0026quot;: |-\rPLAINTEXT:PLAINTEXT,EXTERNAL:PLAINTEXT\rpersistence:\rstorageClass: local-storage\r   这里开启外部访问，配置IP地址（第5行），集群任意节点均可，同时配置storageClass。其他更多配置看官方文档 https://github.com/helm/charts/tree/master/incubator/kafka\n  安装\nhelm install kafka-dev -f kafka-values.yaml incubator/kafka\r   5 查看Kafka版本 kubectl exec kafka-dev-0 -- ls /usr/share/java/kafka | grep kafka\r ","date":1589858158,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589858158,"objectID":"742c6efe4cb1b0be80e485c025fd66e7","permalink":"/posts/helm%E5%AE%89%E8%A3%85kfaka/","publishdate":"2020-05-19T11:15:58+08:00","relpermalink":"/posts/helm%E5%AE%89%E8%A3%85kfaka/","section":"posts","summary":"本文介绍如何使用 helm 安装 Kafka，使用本地存储的方式。 1 配置","tags":[],"title":"Helm安装Kfaka","type":"posts"},{"authors":[],"categories":[],"content":"本文介绍如何使用 helm 安装 MySQL，使用本地存储的方式。\n1 创建StorageClass apiVersion: storage.k8s.io/v1\rkind: StorageClass\rmetadata:\rname: local-storage-mysql\rprovisioner: kubernetes.io/no-provisioner\rvolumeBindingMode: WaitForFirstConsumer\r 这里绑定模式选择 WaitForFirstConsumer\n默认情况下，Immediate 模式指示在创建 PersistentVolumeClaim 之后发生卷绑定和动态配置。 对于拓扑受限且不能从集群中的所有节点全局访问的存储后端，persistentvolume 将在不知道 Pod 的调度需求的情况下进行绑定或提供。 这可能会导致不可调度的Pod。\n集群管理员可以通过指定 WaitForFirstConsumer 模式来解决这个问题，该模式将延迟 PersistentVolume 的绑定和配置，直到创建使用 PersistentVolumeClaim 的 Pod。 Persistentvolumes 将根据 Pod 的调度约束所指定的拓扑结构进行选择或配给。 这些因素包括但不限于资源需求、节点选择器、Pod关联性和反关联性、污染和耐受性。\nLocal 通过预先创建的 PersistentVolume 绑定支持 WaitForFirstConsumer。\n参考：\nhttps://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode\nhttps://kubernetes.io/docs/concepts/storage/volumes/#local\n2 创建PersistentVolume apiVersion: v1\rkind: PersistentVolume\rmetadata:\rname: local-storage-mysql\rspec:\rcapacity:\rstorage: 10Gi\raccessModes:\r- ReadWriteOnce\rpersistentVolumeReclaimPolicy: Retain\rstorageClassName: local-storage-mysql\rlocal:\rpath: /db/mysql\rnodeAffinity:\rrequired:\rnodeSelectorTerms:\r- matchExpressions:\r- key: kubernetes.io/hostname\roperator: In\rvalues:\r- node3\r 使用本地卷时需要 PersistentVolume nodeAffinity。 它使 Kubernetes 调度程序能够将使用本地卷的 Pods 正确调度到正确的节点。\n3 在指定节点上创建存储目录 这里需要在节点 node3 上手动创建存储目录 /db/mysql，Kubernetes不会自动创建它。\n4 安装MySQL helm install my-mysql --set persistence.storageClass=local-storage-mysql stable/mysql\r 这里设置 storageClassName 属性为上面创建的 StorageClass，其他可设置属性参看官方说明 https://github.com/helm/charts/tree/master/stable/mysql#configuration\n","date":1589535447,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589535447,"objectID":"3441f2efa7d9293ac3436fc44107d519","permalink":"/posts/helm%E5%AE%89%E8%A3%85mysql/","publishdate":"2020-05-15T17:37:27+08:00","relpermalink":"/posts/helm%E5%AE%89%E8%A3%85mysql/","section":"posts","summary":"本文介绍如何使用 helm 安装 MySQL，使用本地存储的方式。 1 创建","tags":[],"title":"Helm安装MySQL","type":"posts"},{"authors":[],"categories":[],"content":"安装(CentOS) 1 更新Yum\nsudo yum update\r 2 添加docker仓库并安装docker\ncurl -fsSL https://get.docker.com/ | sh\r 3 启动docker\nsudo systemctl start docker\rsudo systemctl enable docker\r 参考：\nhttps://geekflare.com/docker-installation-guide/\n","date":1589363763,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589363763,"objectID":"c41c58c31a2bb5b936f9171f54049d4c","permalink":"/posts/docker/","publishdate":"2020-05-13T17:56:03+08:00","relpermalink":"/posts/docker/","section":"posts","summary":"安装(CentOS) 1 更新Yum sudo yum update 2 添加docker仓库","tags":[],"title":"Docker","type":"posts"},{"authors":[],"categories":[],"content":"安装 1 在github上创建仓库\u0026lt;USERNAME\u0026gt;.github.io\n2 fork Academic Kickstart 仓库，并clone到本地（替换你的用户名）。\ngit clone https://github.com/\u0026lt;USERNAME\u0026gt;/academic-kickstart.git My_Website\rcd My_Website\rgit submodule update --init --recursive\rgit submodule add -f -b master https://github.com/\u0026lt;USERNAME\u0026gt;/\u0026lt;USERNAME\u0026gt;.github.io.git public\r 3 将所有内容添加到本地 git 存储库，并将其推送到 GitHub 上的远程存储库:\ngit add .\rgit commit -m \u0026quot;Initial commit\u0026quot;\rgit push -u origin master\r 4 通过运行 Hugo 重新生成网站的 HTML 代码，并将 public 子模块上传到 GitHub:\nhugo\rcd public\rgit add .\rgit commit -m \u0026quot;Build website\u0026quot;\rgit push origin master\rcd ..\r 5 通过浏览器访问 https://.github.io\n添加内容 1 创建文件\nhugo new posts/my-first-post.md\r 2 部署脚本 deploy.sh\n#!/bin/sh\r# If a command fails then the deploy stops\rset -e\rprintf \u0026quot;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026quot;\r# Build the project.\rhugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;`\r# Go To Public folder\rcd public\r# Add changes to git.\rgit add .\r# Commit changes.\rmsg=\u0026quot;rebuilding site $(date)\u0026quot;\rif [ -n \u0026quot;$*\u0026quot; ]; then\rmsg=\u0026quot;$*\u0026quot;\rfi\rgit commit -m \u0026quot;$msg\u0026quot;\r# Push source and build repos.\rgit push origin master\r 3 更新网站\n./deploy.sh \u0026quot;Your optional commit message\u0026quot;\r 参考：\nhttps://georgecushen.com/create-your-website-with-hugo/\nhttps://sourcethemes.com/academic/docs/deployment/\n","date":1589355943,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589355943,"objectID":"c61fafe07bc81ef3e7b82d29f8b7c656","permalink":"/posts/hugo-github-pages/","publishdate":"2020-05-13T15:45:43+08:00","relpermalink":"/posts/hugo-github-pages/","section":"posts","summary":"安装 1 在github上创建仓库\u0026lt;USERNAME\u0026gt","tags":[],"title":"Hugo Github Pages","type":"posts"}]